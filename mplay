#!/usr/bin/env python3
##Imports
import copy
import ctypes
import curses
import datetime
import enum
import json
import mpv
import operator
import os
import pickle
import random
import shlex
import subprocess
import sys
import threading
import time
import unicodedata

from collections import defaultdict
from math import ceil
from pathlib import Path

##MAIN
def main(stdscr):
    global screen, COLOR, key, player, magic
    screen = stdscr
    player = mpv.MPV(vid=False, ytdl=True)
    initialize()
    player.volume = app.volume
    while app.running: ## MAIN LOOP 
        if app.updated:
            draw_screen()
        else:
            draw_progress()
        time.sleep(app.settings["app_delay"])
        app.updated = key_handler()
        update_logic()

def on_quit():
    if app.killall:
        kill()
        return
    if app.settings["get_meta_with_ffprobe"] and not app.sync:
        stop_thread_pool()
    if app.master:
        save_sync_data(erase = True)
    elif app.sync:
        time.sleep(.5)
    player.stop()
    kill_midi()
    #stop_recording_stream() #(done elsewhere now)
    if app.error: print(app.error)

##Other Functions
def initialize():
    """Initialize app and curses"""
    global COLOR, screensaver
    COLOR = Color(False) #create temp color class
    set_process_name()
    create_screensavers() #Initialize screensaver data
    config_handler() #load config, create default if config doesn't exist
    request_handler() #handle terminal flags
    screen.nodelay(True) #non-blocking getch call
    screen.keypad(True) #number pad support
    curses.curs_set(False) #hide cursor
    curses.set_escdelay(25) #reduce delay when pressing ESCAPE key
    update_directory(app.settings["start_directory"]) #default is ~/Music

    # Initialize colors and themes
    COLOR = Color(app.settings["use_color"])
    app.style_map = {"normal":curses.A_NORMAL, "dim":curses.A_DIM, "bold":curses.A_BOLD,\
        "underline":curses.A_UNDERLINE, "reverse":curses.A_REVERSE,
        "standout":curses.A_STANDOUT, "blink":curses.A_BLINK,
        "italic":curses.A_ITALIC, "low":curses.A_LOW}
    app.single_colors = [value for key, value in COLOR.map.items() if "-on-" not in key]
    app.single_colors.append(0)
    app.gui_colors = sorted([*COLOR.map.keys()])
    app.theme = make_themes()
    change_theme(app.theme_index, msg = False)

    # Create Metadata view and initialize list views
    view_elements = [
        ViewElement("title", "left", 0),
        ViewElement("artist", "third"),
        ViewElement("album", "half", 5),
        ViewElement("genre", "right", -26),
        ViewElement("year", "right", -13),
        ViewElement("duration", "right", -7)]
    ListView(view_elements, name = "metadata")
    views = "names paths file_info"
    if app.show_tags:
        views += " metadata"
        if app.custom_views:
            for key, value in app.custom_views.items():
                views += f" {key}"
    app.list_view = SimpleState(views.split())
    try:
        app.list_view.set(app.settings["default_view"])
    except ValueError:
        app.list_view.set("names")

    # Show help message and start Thread Pools
    if not app.sync:
        if not app.msg:
            app.send_msg("'Press h' for help")
        if app.settings["get_meta_with_ffprobe"]:
            start_thread_pool()

def start_thread_pool():
    from multiprocessing.pool import ThreadPool
    app.pool = ThreadPool() #can limit threads via (processes = 4)
    app.pool.apply_async(probe_metadata)

def stop_thread_pool():
    app.playlist_to_probe = []
    app.visible_files_to_probe = []
    app.filelist_to_probe = []
    texts = (("quitting", "QUITTING"))
    index = 0
    while(app.quit_counter):
        index = 0 if index else 1
        print(f"\r{texts[index]}", end = '')
        time.sleep(.08)
    for i in range(1,5):
        index = 0 if index else 1
        print(f"\r{texts[index]}", end = '')
        time.sleep(.08)
    app.pool.close()
    app.pool.join()
    print("\rGoodbye.          ")

def set_process_name():
    libc = ctypes.CDLL(None)
    libc.prctl(15,b"mplay", 0, 0, 0)

def get_dict_key(obj):
    """Returns key for value in Color.map"""
    keys = []
    values = []
    for key, value in COLOR.map.items():
        keys.append(key)
        values.append(value)
    try:
        index =  values.index(obj)
    except ValueError:
        return None
    return keys[index]

def split_colors(colr, return_text = False):
    fullcolor = get_dict_key(colr)
    if not fullcolor:
        return 0, 0 ##fixing bugs
    foreground, background = fullcolor.split("-on-")
    if return_text:
        return foreground, background
    else:
        return COLOR.map[foreground], COLOR.map[background]

def get_theme_colors(singles_only = False):
    theme_colors = (app.theme.color_main, app.theme.color_header, app.theme.color_bars,
        app.theme.color_selected, app.theme.color_playing, app.theme.color_icons,
        app.theme.color_screensaver)
    colors = []
    for color in theme_colors:
        if color in app.single_colors:
            colors.append(color)
        else:
            foreground, background = split_colors(color)
            colors.extend((foreground, background))
            if not singles_only:
                colors.append(color)
    if app.theme.color_main not in app.single_colors and not singles_only:
        foreground, background = split_colors(app.theme.color_main, return_text = True)
        c = COLOR.map[f"{background}-on-{foreground}"]
        colors.append(c)
    return colors

def get_standout():
    if not app.settings["entry_standout"]:
        return app.theme.style_header
    style = curses.A_BOLD
    if not app.theme.color_header:
        color = 0
        style = curses.A_REVERSE
    elif true_savers_playing():
        color = COLOR.WHITE
    elif app.theme.color_header == COLOR.WHITE_ON_BLACK:
        color = COLOR.BLACK_ON_WHITE
    else:
        color = COLOR.WHITE_ON_BLACK
    return style + color

def create_screensavers():
    global screensaver
    savers = "eink modem matrix khaos plankton tetragon rave pixels drip frame snow bubbles artists".split()
    screensaver = SimpleState(savers)
    screensaver.data = None
    screensaver.auto_reset = True
    screensaver.particle_override = None
    screensaver.bounce = False
    screensaver.random = False
    screensaver.speed_mod = 1
    screensaver.laser = False
    screensaver.beam = 0
    screensaver.stars = False
    screensaver.wandering = False
    screensaver.engine = 1
    settings = "engine particle speed stars wandering laser bounce".split()
    defaults = (1, None, 1, False, False, False, False)
    for saver in screensaver.states:
        for attr, default in zip(settings, defaults):
            setattr(saver, attr, default)
        setattr(saver, "engine", 5) #Plankton engine by default
    s = screensaver #Temp variable because I'm lazy
    s.eink.engine = 1
    s.modem.engine = 2
    s.drip.engine = s.matrix.engine = 3
    s.frame.engine = s.khaos.engine = 4
    s.tetragon.engine = 6
    s.bubbles.particle = chr(9711)
    s.bubbles.speed = -.10
    s.drip.particle = chr(9617)
    s.drip.speed = 4
    s.frame.particle = ".   ."
    s.frame.bounce = True
    s.frame.speed = -.10
    s.pixels.particle = chr(9607)
    s.rave.particle = chr(9615)
    s.rave.laser = True
    s.snow.particle = chr(10052)
    s.snow.speed = .10
    s.tetragon.stars = True
    s.tetragon.wandering = True
    s.tetragon.fx = SimpleState("stars boxes clouds".split())

def config_handler():
    """Loads config, creates default if config doesn't exist"""
    path = Path(f"~/.config/mplay/mplay.config").expanduser()
    if not path.exists():
        save_config(path, app.settings)
        playlists = Path(f"~/.config/mplay/playlists").expanduser() #new
        timidity = Path(f"~/.config/mplay/timidity/soundfonts").expanduser()
        playlists.mkdir(parents = True, exist_ok = True) #new
        timidity.mkdir(parents = True, exist_ok = True)

    app.settings = load_config(path, app.settings)
    app.settings["app_delay"] = min(app.settings["app_delay"], .05)
    app.settings["app_delay"] = max(app.settings["app_delay"], .001)
    app.fps = app.settings.get("fps", 60)
    app.list_view = app.settings.get("default_view", "names")

    if app.settings["default_theme"]:
        app.theme_index = app.settings["default_theme"] #attempt to fix bug
    if app.settings.get("screensaver", 0):
        screensaver.engine = app.settings["screensaver"]
        app.screensaver_time = max(2, app.settings.get("screensaver_time", 30))

    additional_extensions = app.settings.get("add_support_for", None)
    if additional_extensions:
        additional_extensions = additional_extensions.replace(' ', '')
        if ',' in additional_extensions:
            app.extensions.extend(additional_extensions.split(','))
        else:
            app.extensions.append(additional_extensions)

def request_handler():
    """Handles requests (command line arguments)"""
    start_pools = True
    valid_requests = "color,theme,m,mono,check_mime,s,show_metadata,fast,f,b,bold,r,p,reverse,screensaver,screensaver_time,fps,master,sync,stats,kill,g,goto,radio,playlists,volume,scroll".split(',')
    if request('h', "help") or (request.made and not request.first and not request(*valid_requests)):
        app.error = "\n".join(app.help_text)
        start_pools = False
    if request("kill"):
        app.killall = True
        app.running = False
    if request("m", "mono"):
        app.settings["use_color"] = False
    if request('b', "bold"):
        if request('r',"reverse"):
            app.error = "Error: Bold and Reverse can not be used together"
            app.running = False
        else:
            curses.A_NORMAL, curses.A_DIM = curses.A_BOLD, curses.A_BOLD
    if request('r', "reverse"):
        app.reverse_colors = True

    if request("theme") and request.theme and request.theme.isdecimal():
        app.settings["default_theme"] = app.theme_index = int(request.theme)
    if request("color"):
        if request.color == '?':
            start_pools = False

        app.settings["color_override"] = request.color
    if request("screensaver") and request.screensaver.isdecimal():
        screensaver.engine = min(int(request.screensaver), 6)
    elif request("screensaver") and request.screensaver in ["eink","modem","matrix","khaos","plankton","tetragon"]:
        screensaver.engine = ["eink","modem","matrix","khaos","plankton","tetragon"].index(request.screensaver) + 1
    elif request("screensaver") and request.screensaver in {"rave", "pixels", "drip", "geometric", "artists", "bubbles", "snow", "random"}:
        screensaver.engine = 1
        if request.screensaver == "random":
            #app.settings["screensaver"] = screensaver.engine = 1
            screensaver.random = True
        change_saver(request.screensaver)
    if screensaver.engine == 6:
        change_saver(request.screensaver)

    if request("screensaver_time") and request.screensaver_time.replace('.', '', 1).isdecimal():
        app.screensaver_time = max(2, float(request.screensaver_time))
    if request("scroll"):
        app.settings["pageflip"] = False
    if request("master"):
        app.master = True
    if request("sync"):
        app.sync = True
        if not request("screensaver"): screensaver.engine = 2
        if not request("theme"): app.settings["default_theme"] = app.theme_index = 1
        app.screensaver_time = .5
        app.volume = 0
        app.mode = "playlist"
    if request("stats"):
        app.show_system_stats = True
    if request("fps") and request.fps.isdecimal():
        app.fps = app.settings["fps"] = int(request.fps)
        if app.fps == 0: app.fps = 1
        if 1/app.fps < app.settings["app_delay"]:
            app.settings["app_delay"] = (1/app.fps)
    if request("check_mime"):
        try:
            global magic
            import magic
        except ModuleNotFoundError:
            app.send_msg("Error: python3-magic not installed")
        else:
            app.check_mime = True
            app.settings["show_dir_size"] = False
    if request("midi_config") and request.midi_config is not None:
        file = app.midi_config = Path(request.midi_config)
        if not file.expanduser().exists():
            file = app.midi_config = Path(f"~/.config/mplay/timidity/{file}")
            if not file.expanduser().exists():
                app.midi_config = None
                app.send_msg("Error: Midi config not found")
    if request('f', "fast", "check_mime", "kill") or not start_pools:
        app.settings["get_meta_with_musictag"] = False
        app.settings["get_meta_with_ffprobe"] = False
        app.settings["show_dir_size"] = False
        screensaver.engine = 0

    elif request('s', "show_metadata") or app.settings["get_meta_with_musictag"]:
        app.settings["get_meta_with_musictag"] = True
        if request('s', "show_metadata"):
            app.settings["get_meta_with_ffprobe"] = True
        try:
            import music_tag
            app.music_tag = music_tag
        except ModuleNotFoundError:
            app.music_tag = None
            msg = "Error: 'music-tag' not installed"
            app.send_msg(msg)

    if request('g', "goto"):
        try:
            search = request.g
        except AttributeError:
            search = request.goto
        if search and search.isalnum():
            cmd1 = f'find -H -type d -name "{search}" | head -n 1'
            cmd2 = f'find -H ~/ -type d -name "{search}" | head -n 1'
            with os.popen(cmd1) as p:
                r = p.read().strip()
            if not r:
                with os.popen(cmd2) as p:
                    r = p.read().strip()
            if r:
                request.first = r
    if request("radio") and not request.first:
        request.first = "~/.config/mplay/playlists/net_radio.m3u"
    elif request("playlists", "playlist", 'p') and not request.first:
        request.first = "~/.config/mplay/playlists/"

    if request.first is not None:
        if request.first.endswith(".m3u"): #handle playlist
            dir = Path(app.settings["start_directory"]).expanduser()
            update_directory(dir) #need to create filelist first
            path = request.first
            if '/' not in path:
                path = Path(f"~/.config/mplay/playlists/{path}")
            else:
                path = Path(path) #new, trying to fix bug
            try:
                load_playlist(FileObj(path.expanduser(), hidden = True)) #start the playlist
            except FileNotFoundError:
                app.send_msg("Error: Playlist does not exist")

        else:
            app.settings["start_directory"] = request.first
            path = Path(app.settings["start_directory"]).expanduser()
            if not path.exists():
                app.settings["start_directory"] = Path("~/").expanduser()
                app.send_msg("Error: Directory not found!")
    if app.settings["get_meta_with_musictag"] or app.settings["get_meta_with_ffprobe"]:
        app.show_tags = True
        app.list_view = app.settings["default_view"] or "metadata"
    else:
        app.list_view = "names"

    if request("volume") and request.volume and request.volume.isdigit():
        vol = int(request.volume)
        app.volume = sorted((vol, 0, 130))[1] #clamp
    if app.error:
        app.running = False
    return app.settings

def key_handler():
    """returns app update status (whether or not to redraw screen)"""
    key.detect()
    curses.flushinp() #clear input buffer
    if key.pressed and key.pressed in "WERTYUIOPASDFGHJKLZXCVBNM" and detect_capslock():
        curses.flash(); screen.refresh()
        app.send_msg("ALERT: CAPS LOCK IS ON", 1)
        return True
    if app.kiosk_mode and key.pressed and not key.pressed == 'C':
        return False
    k = key.pressed or '-'
    if key.raw is None:
        app.last_key = ''
        if not player.filename == app.current_file: return True
        if app.is_probing: return True
        if app.screensaver_running and app.last_touched + app.screensaver_time < time.time(): return True
        return False #app not updated
    if app.mode == "help":
        if any((not app.debug, (app.debug and key('h', 'H', "BACKSPACE")))):
            toggle_help()
        if app.debug and not key('C', '<', '>', ',', '.'): return True
        elif not app.debug and not key('C'): return True

    if app.sync and key.pressed not in "`qQ12345678l?!@#$%^&*fcC" and not key("SPACE"): return

    if key('q'): quit()
    elif key('Q'): quit(now = True)
    elif key('r'): toggle_reverse(),
    elif key('R') and app.mode == "filelist": reload_dir()
    elif key('n', 'd', 's', 't', 'R', 'u'):
        sortby({'n':'sort_name', 'd':'date', 's':'size', 't':"title", 'R':"artist", 'u':"duration"}[key.pressed]),
    elif key("UP", "DOWN", 'j', 'k', "PG_UP", "PG_DOWN", "HOME", "END", 'J', 'K'):
        change_index(key.pressed)
    elif key.raw == 8:
        change_index("HOME")
    elif key.raw == 5:
        change_index("END")
    elif key("BACKSPACE"):
        backspace_handler()
    elif key("LEFT"): seek(-5)
    elif key("RIGHT"): seek(5)
    elif key("ENTER") and not app.screensaver_running and not key.repeating:
        play_handler()
    elif key('a'):
        append() if app.mode == "filelist" else sortby("album")
    elif key("TAB"): toggle_playlist()
    elif key('p'): play_or_pause()
    elif key('z', 'Z'): toggle_pause()

    elif key('x'): stop()
    elif key(',','<'): play_handler("prev")
    elif key('.', '>'): play_handler("next")
    elif key('/') and is_file(app.file) and app.file.is_stream:
        record_stream(app.file.url, msg = True)

    elif key("{") and app.mode == "playlist": move_entry_up()
    elif key("}") and app.mode == "playlist": move_entry_down()
    elif key('O'): open_app()
    elif key('g'): goto()
    elif key('m') and not app.screensaver_running: mark()
    elif key("SPACE") and not app.screensaver_running:
        if app.sync:
            pass
        elif app.settings["spacebar_play_or_pause"]:
            play_or_pause()
        else:
            mark()
    elif key("SPACE") and matrix_playing():
        flood_particles_matrix()
    elif key("SPACE") and plankton_playing():
        flood_particles_plankton()
    elif key("SPACE") and khaos_playing():
        shrink_particles()

    elif key('C'): command_entry()
    elif key('U'): unmark_all()
    elif key('i'): inverse_selection()
    elif key('I') and app.music_tag: open_image()
    elif key('D', "DELETE"): delete_from_playlist()
    elif key('h'): toggle_help()
    elif key('H', '~') and app.mode == "filelist": update_directory("~/")
    elif key('P'):
        if app.mode == "playlist":
            sortby("playlist_pos")
        else:
            show_playlists()    

    elif key('M') and app.mode == "filelist":
        update_directory(app.settings["music_directory"])
    elif key('M') and app.mode == "playlist":
        toggle_playmode()
    elif key('f') and app.sync:
        app.show_sync_footer = not app.show_sync_footer

    elif key('f'): filter()
    elif key('F'): find()
    elif key('G'): find(again = True)
    elif key('1','2','3','4','5','6','7','8'):
        change_theme(int(key.pressed))
    elif key('l'): toggle_list()
    elif key(';'): toggle_list(prev = True)
    elif key('L') and app.mode == "playlist": toggle_looping()
    elif key('T'):
        app.theme = make_themes(reset = True)
    elif key('\\'):
        load_midi_config()
    elif key("INSERT", '|') and app.mode == "playlist":
        add_midi_config()
    elif key('-', '_'): change_volume(-5)
    elif key('+', '='): change_volume(5)
    elif key('`'): change_theme(0)
    elif key('('):
        cycle_colors(-1)
    elif key(')'):
        cycle_colors(1)
    elif key('c') and khaos_playing():
        burst_of_color()
    elif key('c') and plankton_playing():
        screensaver.reset = True

    elif key('c') and not app.sync: toggle_remaining()
    elif key('S') and app.mode == "playlist":
        shuffle_playlist()
    elif key('E') and app.mode == "playlist": erase_playlist()
    elif key('W'): write_playlist()
    elif key('!', '@', '#', '$', '%', '^', '&', '*'): change_screensaver_by_key(key.pressed)
    elif key('?'):
        if app.screensaver_running:
            app.show_system_stats = not app.show_system_stats
        else:
            app.last_touched = -9999
            screensaver.engine = screensaver.engine or 1
            app.screensaver_running = True

    elif key.raw in (20, 1, 18, 7, 25) and app.music_tag:
        tags = {20:"title", 1:"album", 18:"artist", 7:"genre", 25:"year"}
        apply_tags(tags[key.raw])
    curses.flushinp() #clear input buffer
    keys_saver_ignores = "- _ = + ( ) ? C".split()
    if app.screensaver_running: keys_saver_ignores.extend(", < > . ! @ # $ % ^ & *".split())

    if app.sync:
        keys_saver_ignores.extend(('f', 'c'))
    if app.sync and key("SPACE"):
        pass
    elif key.pressed not in keys_saver_ignores:
        app.last_touched = time.time()
    app.last_key = key.pressed
    return True

def key_is_repeating():
    if app.last_key == key.pressed and time.time() <  app.last_touched + .25:
        return True
    return False

def quit(now = False):
    if not now and not confirmation():
        return True
    else:
        app.running = False
        if app.master: save_sync_data()

def get_process_name(pid):
    result = os.popen(f"cat /proc/{pid}/comm").read().strip()
    return result

def kill_process(pid):
    return os.popen(f"kill -9 {pid}").read().strip()

def kill_all():
    result = os.popen(f"ps -eo pid,ppid,comm").read().splitlines()
    for process in result:
        item = " ".join(process.strip().split())
        pid, ppid, cmd = item.split(" ", 2)
        if cmd in ("timidity","ffprobe","streamripper"):
            parent = get_process_name(ppid)
            if "mplay" not in parent:
                continue
            result = kill_process(pid)
            result = kill_process(ppid)
            print(f"Killed {cmd} ({pid}) and parent ({ppid})")

def kill():
    data = SyncData(quit = True)
    save_sync_data(data)
    print("Killing...")
    kill_all()
    time.sleep(.5)
    save_sync_data(erase = True)
    print("Done.")

def backspace_handler():
    if app.screensaver_running: return
    if app.mode == "playlist":
        if app.playlist_filter:
            app.playlist_filter = ''
            unfilter_playlist()
        else:
            toggle_playlist()
    else:
        if app.filter:
            app.filter = ''
            unfilter_filelist()
        else:
            update_directory("../")

def seek(amount):
    try:
        if not player.seekable or app.file.is_mod or app.file.is_midi: return
        player.seek(amount)
    except (SystemError, AttributeError):
        pass

def change_index(key):
    app.moving_down = False
    if app.mode == "playlist":
        index = app.playlist_index
        array = app.playlist
        count = len(app.playlist)-1
    else:
        index = app.index
        array = app.all
        count = len(app.all)-1
    dheight = (screen.getmaxyx()[0] - 4)
    if key in ("UP", 'k'):
        index -= 1
        if index < 0:
            index = len(array) - 1
        app.show_page = False
    elif key in ("DOWN", 'j'):
        index += 1
        if index >= len(array):
            index = 0
        app.moving_down = True
        app.show_page = False

    elif key in ("PG_UP", 'K'):
        index -= dheight
        if index < 0 and index >= -(dheight-1):
            index = 0
        page = int(index/dheight)
        if page == 0: index = 0
        app.show_page = True
    elif key in ("PG_DOWN", 'J'):
        index += dheight
        if index > count and index - count < dheight:
            index = count
        app.show_page = True
    elif key == "HOME":
        index = 0
    elif key == "END":
        if app.mode == "playlist":
            index = 0 or len(app.playlist) - 1
        else:
            index = len(app.all) - 1

    if app.mode == "playlist":
        app.playlist_index = index
    else:
        app.index = index

def play_handler(index = None):
    if app.mode == "filelist":
        try:
            item = app.all[app.index]
        except IndexError:
            return
        if is_file(item, ext = "m3u"):
            if app.playlist\
            and not confirmation("Open playlist, clearing current one? (y/n) "):
                return
            load_playlist(item)
            return
        play_file(index)
    else:
        play_playlist(index)
    if screensaver.random:
        randomize_screensaver()

def play_streaming(file):
    if not is_file(file): return
    if not file.is_stream: return
    app.is_streaming = True
    app.stream_file = file
    app.stream_start_time = time.perf_counter()
    app.stream_pos = 0
    app.send_msg(f"Loading stream...", 1)
    player.play(file.url)

def get_streaming_metadata():
    app.stream_counter += 1
    if app.stream_counter > 9999:
        app.stream_counter = 0
    if app.stream_counter % 50:
        return

    obj = app.file
    if not is_file(obj) or not obj.is_stream:
        if app.stream_file:
            obj = app.stream_file
        else:
            return

    prev_title = obj.title
    prev_station = obj.station
    try:
        tags = player.metadata or {}
    except AttributeError:
        tags = {}
    if not tags:
        return

    obj.title = tags.get("icy-title", obj.name)
    artist = tags.get("ARTIST", '')
    if obj.title == obj.name or artist.lower() == "artist":
        obj.title = tags.get("TITLE", obj.name)
        if artist:
            obj.title = f"{artist} - {obj.title}"

#FOR DEBUG USE ONLY
#    if obj.title == obj.name and not "icy-notice2" in tags:
#        raise Exception(str(tags))

    obj.genre = tags.get("icy-genre", "streaming")
    obj.station = obj.album = tags.get("icy-name", '')
    obj.website = obj.artist = tags.get("icy-url", '')
    obj.rate = tags.get("icy-br", '')
    if obj.rate:
        obj.rate = f"{obj.rate} kbs"
    if not prev_title == obj.title or ((prev_station and obj.station) and not prev_station == obj.station):
        app.stream_file = obj
        app.updated = True
        if app.master: save_sync_data()
        if app.settings["streaming_log"]:
            log_stream(obj)
        app.stream_start_time = time.perf_counter()
        app.stream_pos = 0

def log_stream(obj, record = False):
    file = Path("~/.config/mplay/logs/streaming.log").expanduser()
    dirname = Path(file).parent
    dirname.mkdir(parents = True, exist_ok = True)
    now = str(datetime.datetime.now())
    status = "[RECORDING] " if record else ''
    data = f"{now[:-4]}    {obj.station.ljust(19)[:19]}    {status}{obj.title}\n"
    with open (file, 'a') as f:
        f.write(data)

def streamripper(url, dir):
    user_agent = "FreeAmp/2.x"
    cmd = f'streamripper "{url}" -d "{dir}" -u "{user_agent}" -t -r -q -k 0 -M 1000'
    args = shlex.split(cmd)
    popen = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, bufsize=1, universal_newlines=True)
    key = Key()
    lines = []
    max_height, max_width = screen.getmaxyx()
    error = False
    last = None
    station = None
    bps = None
    start_time = time.perf_counter()
    if not app.theme.color_header in app.single_colors:
        foreground, background = split_colors(app.theme.color_header, return_text = True)
    else:
        foreground, background = '', ''
    if "red" in (foreground, background) or app.theme.color_header == COLOR.RED:
            style = curses.A_BOLD + COLOR.BLACK_ON_GREEN
    else:
        style = curses.A_BOLD + COLOR.BLACK_ON_RED

    while True:
        key.detect()
        curses.flushinp() #clear input buffer
        if key('q', 'Q', 'x', '/'):
            cprint("    Stopping streamripper...", x = -28, y = 0, style = curses.A_BOLD + COLOR.WHITE_ON_RED)
            screen.refresh()
            break
        elif key('-', '_'): change_volume(-5)
        elif key('+', '='): change_volume(5)
        elif key('z'): toggle_pause()

        if app.master:
            get_streaming_metadata() 
        if not player.filename and app.playing:
            reconnect_stream()
        try:
            r = popen.stdout.readline()
        except UnicodeDecodeError:
            r = '' ## or "(DECODE ERROR)" if you wished to continue recording
        if not station and "stream: " in r:
            station = r.split("stream: ")[1].strip()
        if not bps and "bitrate: " in r:
            bps = r.split("bitrate: ")[1].strip()
        if not r or "ERROR" in r:
            error = True
            break
        if not last == r:
            lines.append(r.strip())
            last = r
        if len(lines) > max_height-4:
            lines.pop(0)
        ##Draw screen
        screen.erase()
        for n in (1,-2): #draw seperators
            draw_hline(x = 0, y = n, style = app.theme.style_bars)
        header = "RECORDING: via streamripper "
        if station:
            header = f"RECORDING: {station[:32]} "
        cprint(header, x = 0, y = 0, style = style, fill = True)
        cprint("~/Downloads/mplay_recordings", x = -28, y = 0, style = style)
        screen.bkgd(' ', app.theme.style_main)
        for i, line in enumerate(lines):
            cprint(' ', x = 0, y = 2+i, style = app.theme.style_main, fill = True)
            cprint(line, x = 2, y = 2+i, style = app.theme.style_main)
        cprint("Press 'x' to stop recording", x = 0, y = -1, justify = "center", style = app.theme.style_header, fill = True)
        if bps:
            cprint(f"{bps} kbs", x = 0, y = -1, style = app.theme.style_header)
        ptime = time.perf_counter() - start_time
        cprint(f" {format_time(ptime)}", x=-12, y=-1, justify = "right", style = app.theme.style_header)
        screen.refresh()
    #End while
    popen.stdout.close()
    screen.bkgd(' ', 0)
    return popen, error

def record_stream(url, msg = True):
    if app.stream_file and app.settings["streaming_log"]:
        log_stream(app.stream_file, record = True)
    dir = Path("~/Downloads/mplay_recordings").expanduser()
    dir.mkdir(parents = True, exist_ok = True)
    try:
        popen, error = streamripper(url, dir)
        if error: msg = "Error: Recording Stopped!"
        else: msg = "Recording: OFF"
    except FileNotFoundError:
        msg = "Error, is Streamripper installed?"
        popen = None
    stop_recording_stream(popen, msg)

def stop_recording_stream(popen, msg = None):
    if popen is not None:
        popen.terminate()
        popen.wait()
    if msg: app.send_msg(msg)

def play_playlist(index = None, user_input = True):
    if index in ("next", "prev"):
        if modem_playing():
            screensaver.data = None
        elif khaos_playing():
            khaos_transition()
        elif matrix_playing():
            matrix_transition()
        elif plankton_playing():
            plankton_transition()
        elif tetragon_playing():
            tetragon_transition()

        if app.playmode == "random" and app.playlist:
            n = 0
            indexes = range(0, len(app.playlist))
            while True:
                index = random.choice(indexes)
                n += 1
                if not index == app.index_playing or n > 100: break
        elif index == "next":
            index = app.index_playing + 1 if app.playlist_is_playing else 0
        elif index == "prev":
            index = app.index_playing - 1 if app.playlist_is_playing else len(app.playlist)-1
        if app.settings["index_follow_playlist"] or user_input:
            app.playlist_index = index
    else:
        index = app.playlist_index
    if not app.playlist_is_playing:
        app.playlist_is_playing = True
    if index < 0: index = len(app.playlist) - 1
    elif index >= len(app.playlist):
        if app.looping or user_input:
            index = 0
        else:
            stop()
            return
    play(index, True)

def toggle_looping():
    app.looping = not app.looping
    state = " on" if app.looping else "off"
    app.send_msg(f"Looping: {state}")

def toggle_playmode():
    app.playmode.next()
    app.send_msg(f"Mode: {app.playmode}")

def play_file(index = None): # Plays single file in filelist (was play_oneshot)
    if index in ("next", "prev"):
        if modem_playing():
            screensaver.data = None
        elif khaos_playing():
            khaos_transition()
        elif matrix_playing():
            matrix_transition()
        elif plankton_playing():
            plankton_transition()
        elif tetragon_playing():
            tetragon_transition()
        index = find_playable(index)
    else:
        index = app.index
        if is_file(app.all[index]):
            app.playlist_is_playing = False
    if index is not None:
        play(index)

def find_playable(index):
    valid_indexes = [i for i, obj in enumerate(app.all) if is_file(obj)] or [0]
    names = [item.name for item in app.all if type(item) != str]
    if player.filename and player.filename not in names:
        app.index_playing = 0
    if index == "next":
        for n in valid_indexes:
            if n > app.index_playing:
                index = n
                break
        if index == "next":
            index = min(valid_indexes)
    elif index == "prev":
        for n in reversed(valid_indexes):
            if n < app.index_playing:
                index = n
                break
        if index == "prev":
            index = max(valid_indexes)
    if index < 0: index = len(app.all) - 1
    elif index >= len(app.all): index = 0
    app.index = index
    try:
        obj = app.all[index]
        if not is_file(obj):
            index = None
    except (AttributeError, IndexError):
        index = None
    return index

def play(index, isPlaylist = False):
    if isPlaylist:
        try:
            app.file = app.playlist[index]
            # This was newly added to handle m3u files within playlist
            # 1st attempt placed it in play_handler, but broke Mplay badly
            if is_file(app.file, ext = "m3u"):
                if not confirmation("Open playlist, clearing current one? (y/n) "):
                    return
                load_playlist(app.file)
                return

        except IndexError:
            app.playlist_is_playing = False
            app.playlist_index = 0
            app.file_object_playing = None
            return True

    else:
        app.file = app.all[index]
        app.playlist_index = 0
    if is_file(app.file):
        app.file_object_playing = app.file

        if app.master: save_sync_data()
        if not app.file.is_stream:
            app.is_streaming = False
            app.stream_file = None
        app.index_playing = index
        player.pause = False
        fullpath = app.file.fullpath
        if app.file.ext == "mid":
            play_midi(app.file)
        elif app.file.is_stream:
            if app.midi_is_playing:
                kill_midi()
            play_streaming(app.file)
        else:
            if app.midi_is_playing:
                kill_midi()
            if app.playlist_is_playing and app.file.volume:
                player.volume = min(130, (app.volume + app.file.volume - 100))
            else:
                player.volume = app.volume
            if not Path.exists(Path(fullpath)):
                app.send_msg("Error: File not found, playback stopped", 3)
                stop()
                return

            player.play(str(fullpath)) ##PLAYS audio via MPV
        app.playing = True
        app.play_index = index
        return True
    else:
        try:
            path = app.file.path
        except AttributeError: #when app.file = "../"
            path = app.file
    update_directory(path)

def convert_midi(obj):
    array = app.playlist if app.mode == "playlist" else app.all
    marked = [item for item in array if not type(item) is str and item.marked and item.ext == 'mid']
    if not marked and (not obj or not app.midi_is_playing):
        current_index = app.playlist_index if app.mode == "playlist" else app.index
        obj = array[current_index]
    if not marked and not is_file(obj, ext = 'mid'): return "Error, not a MIDI file"

    if marked:
        msg = f"Convert {len(marked)} marked midi(s) to mp3? (y/n)"
    else:
        msg = f"Convert '{obj.path.stem}' to audio? (y/n)"
    try:
        if not marked and confirmation(msg):
            fname = get_text(f"Enter file name: ~/Music/mplay_exported/midi_conversions/",\
                default_text=obj.path.stem + ".mp3")
            if not fname: raise NameError
        elif marked and confirmation(msg):
            pass
        else:
            raise NameError
    except NameError:
        return "Conversion cancelled"

    if marked: objects = marked
    else: objects = [obj]
    path = Path(f"~/Music/mplay_exports/midi_conversions/").expanduser()
    path.mkdir(parents = True, exist_ok = True)
    if not marked:
        path = Path(f"~/Music/mplay_exports/midi_conversions/{fname}").expanduser()
        if Path.exists(path) and not confirmation("File exists, overwrite? (y/n)"):
            return "Conversion cancelled"
    size = len(objects)
    for i, obj in enumerate(objects):
        if obj.midi_config:
            midi_config = obj.midi_config
        else:
            midi_config = app.midi_config
        show_copy_progress(i, size)
        mc = '' if not midi_config else f"_{midi_config.stem}"
        if marked:
            path = Path(f"~/Music/mplay_exports/midi_conversions/{obj.path.stem}{mc}.mp3").expanduser()
        if midi_config:
            cmd = f"timidity -c {midi_config} '{obj.fullpath}' -Ow -o - | ffmpeg -y -f wav -i - '{path}'"
        else:
            cmd = f"timidity '{obj.fullpath}' -Ow -o - | ffmpeg -y -f wav -i - '{path}'"
        try:
            s = subprocess.Popen(cmd, shell=True, stdout = subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            if not s: raise FileNotFoundError
            if s.returncode: return "Error, conversion failed"
        except (FileNotFoundError, AttributeError):
            app.send_msg("Error: Timidity required for midi conversion")
        except SyntaxError:
            app.send_msg("Error: There is a problem with Timidity config")
    count = 1 if not marked else len(marked)
    return f"{count} file(s) converted"

def play_midi(obj):
    file = obj.fullpath
    kill_midi()
    app.midi_start_time = time.perf_counter()
    app.midi_is_playing = True
    app.playing = True
    player.stop()
    if obj.volume: #adjust volume based on loaded vol
        volume = max(20, (app.volume + obj.volume - 100))
    else:
        volume = max(20, app.volume)

    vol = f"-A{volume-20},{volume-10}"
    if obj.midi_config:
        midi_config = obj.midi_config
    else:
        midi_config = app.midi_config

    #Added the following to stop race condition when file not found
    if not Path.exists(file):
        app.send_msg("Error: File not found, midi playback stopped", 5)
        app.playlist_is_playing = False
        app.midi_is_playing = False
        app.playing = False
        return

    try:
        if midi_config:
            stdout = []
            stderr = None
            s = run("timidity", vol, "-c", midi_config, file, stderr = subprocess.PIPE)
            try:
                stdout, stderr = s.communicate(timeout = .1)
                s.stdout.close() #might not be needed
            except subprocess.TimeoutExpired:
                pass
            if stderr:
                raise SyntaxError
        else:
            s = run("timidity", vol, file)
        if not s: raise FileNotFoundError
        app.midi_pid = s.pid
        app.midi_filename = app.file.name
        app.midi_process = s
    except (FileNotFoundError, AttributeError):
        app.send_msg("Error: Timidity required for midi playback")
    except SyntaxError:
        app.send_msg("Error: There is a problem with Timidity config")
        kill_midi()
        stop()

def kill_midi():
    if app.midi_process is not None:
        app.midi_process.terminate()
    elif app.midi_pid is not None:
        try:
            os.kill(app.midi_pid, 1)
        except (TypeError, ProcessLookupError):
            pass
    app.midi_pid = None
    app.midi_process = None
    app.midi_filename = ''
    app.midi_is_playing = False
    app.playing = False

def load_midi_config(config = None):
    if not config:
        config = get_text("Midi config to load? ", allow_spaces = True)
    path = Path(f"~/.config/mplay/timidity/{config}").expanduser()
    if not config:
        try:
            current = app.midi_config.stem
        except (TypeError, AttributeError):
            current = "default"
        app.send_msg(f"MIDI using '{current}'")
        return
    elif config.lower() in ["none", "default"]:
        app.midi_config = None
        app.send_msg("Default midi config")
    elif path.exists():
        app.midi_config = path
        app.send_msg(f"'{config}' config loaded")
    else:
        app.send_msg(f"Error: '{config}' not found")
        return
    if app.midi_is_playing and app.file.is_midi:
        play_midi(app.file)

def add_midi_config():
    try:
        file = app.playlist[app.playlist_index]
    except IndexError:
        return
    if not file.is_midi: return
    if not confirmation("Apply midi config? (y/n)"):
        return
    marked = 0
    for obj in app.playlist:
        if obj.marked:
            if is_file(obj, ext = "mid"):
                obj.midi_config = app.midi_config or None
            obj.marked = False ##changed to unmark files that aren't midi
            marked += 1
    if not marked:
        file.midi_config = app.midi_config or None
    app.updated = True

def process_running(pid):
    try:
        os.kill(pid, 0)
    except (OSError, TypeError):
        return False
    else:
        return True

def reload_dir():
    unfilter_filelist()
    app.send_msg("Directory Reloaded")
    screen.clear()
    update_directory(app.cwd)
    app.updated = True

def make_themes(reset = False):
    alt = get_color_override(reset)
    app.themes = {}
    for func in (make_theme_custom, make_theme_1, make_theme_2, make_theme_3,\
        make_theme_4, make_theme_5, make_theme_6, make_theme_7, make_theme_8):
        func(alt)
    for theme in app.themes.values():
        theme.extract_colors()
    if app.master:
        if reset: app.settings["color_override"] = None
        save_sync_data()

    if reset:
        change_theme(app.theme_index, msg = False)
        app.send_msg("Themes reset")
        return app.themes[app.theme_index]
    if app.settings["use_color"]:
        index = app.settings["default_theme"]
    else:
        index = 0
    try:
        return app.themes[index]
    except KeyError:
        return app.themes[0]

def get_color_override(reset = False):
    alt = None
    if app.settings["color_override"] and not reset:
        try:
            alt = COLOR.map[app.settings["color_override"]]
        except KeyError:
            app.running = False
            keys = ', '.join(sorted(COLOR.map.keys()))
            app.error = f"Error: '{app.settings['color_override']}' is not a valid color\n\nValid colors: {keys}"
    return alt

def make_theme_custom(alt):
    if app.settings["custom_theme_style_main"] and app.settings["use_color"]:
        main_style = app.settings["custom_theme_style_main"]
        app.custom_theme = Theme()
        for item in ("main", "header", "bars", "selected", "playing", "icons"):
            key = f"style_{item}"
            style = convert_to_curses(app.settings.get(f"custom_theme_{key}", main_style) or main_style)
            setattr(app.custom_theme, key, style)
        app.custom_theme.extract_colors()
        app.themes[0] = app.custom_theme
    else:
        app.themes[0] = Theme()
        app.themes[0].extract_colors()

def make_theme_1(alt):
    """A simple theme"""
    app.themes[1] = Theme(\
        style_main = alt or COLOR.GREEN,
        style_header = (alt or COLOR.GREEN) + curses.A_BOLD + curses.A_REVERSE,
        style_bars = (alt or COLOR.GREEN) + curses.A_BOLD,
        style_selected = (alt or COLOR.GREEN_ON_BLACK) + curses.A_REVERSE,
        style_playing = (alt or COLOR.GREEN) + curses.A_BOLD,
        style_icons = (alt or COLOR.GREEN) + curses.A_BOLD) 

def make_theme_2(alt):
    """This theme has lots of overrides"""
    app.themes[2] = Theme(\
        style_main = COLOR.BLACK_ON_GREEN + curses.A_BOLD,
        style_header = COLOR.GREEN_ON_BLACK,
        style_bars = COLOR.RED_ON_BLACK,
        style_selected = COLOR.BLACK_ON_GREEN + curses.A_REVERSE + curses.A_DIM,
        style_playing = COLOR.BLACK_ON_GREEN + curses.A_BOLD,
        style_icons = COLOR.GREEN_ON_BLACK + curses.A_BOLD)
    theme = app.themes[2]
    if alt == COLOR.GREEN_ON_BLACK:
        theme.style_bars = COLOR.RED_ON_BLACK
        theme.style_header = COLOR.GREEN_ON_BLACK
    elif alt:
        theme = app.themes[2]
        theme.style_main = theme.style_header = COLOR.WHITE
        theme.style_bars = theme.style_icons = alt + curses.A_BOLD
        theme.style_selected = alt + curses.A_REVERSE + curses.A_BOLD
        theme.style_playing = alt
        if alt not in app.single_colors:
            foreground, background = split_colors(alt)
            if foreground in (COLOR.WHITE, COLOR.BLACK):
                theme.style_playing = background + curses.A_BOLD
            else:
                theme.style_playing = foreground + curses.A_BOLD
            if background == COLOR.BLACK:
                ftext = get_dict_key(foreground)
                btext = get_dict_key(background) 
                try:
                    reversed = COLOR.map[f"{btext}-on-{ftext}"]
                except KeyError:
                    reversed = None
                if reversed:
                    theme.style_main = reversed + curses.A_BOLD
                    theme.style_playing = reversed + curses.A_BOLD
                    theme.style_header = COLOR.WHITE_ON_BLACK + curses.A_BOLD
                    theme.style_selected = reversed + curses.A_REVERSE + curses.A_DIM
                    if alt == COLOR.WHITE_ON_BLACK:
                        theme.style_selected = COLOR.MAGENTA_ON_WHITE + curses.A_REVERSE + curses.A_DIM

def make_theme_3(alt):
    app.themes[3] = Theme(\
        style_main = (alt or COLOR.RED_ON_BLACK) + curses.A_REVERSE + curses.A_DIM,
        style_header = (alt or COLOR.BLACK_ON_RED) + curses.A_REVERSE + curses.A_BOLD,
        style_bars = (alt or COLOR.RED_ON_BLACK) + curses.A_REVERSE + curses.A_BOLD,
        style_selected = COLOR.BLACK_ON_WHITE + curses.A_REVERSE + curses.A_DIM,
        style_playing = (alt or COLOR.RED_ON_BLACK) + curses.A_REVERSE + curses.A_DIM,
        style_icons = (alt or COLOR.RED_ON_BLACK) + curses.A_REVERSE + curses.A_BOLD)
    theme = app.themes[3]
    if not alt:
        color = extract_color(theme.style_main)
    else:
        color = alt
    if color not in app.single_colors:
        foreground, background = split_colors(color)
        ftext, btext = split_colors(color, return_text = True)
        try:
            reversed = COLOR.map[f"{btext}-on-{ftext}"]
        except KeyError:
            reversed = False
        if background == COLOR.BLACK or COLOR.BLUE:
            theme.style_header = COLOR.WHITE_ON_BLACK + curses.A_BOLD
            theme.style_main = foreground + curses.A_REVERSE + curses.A_DIM
            theme.style_playing = theme.style_main
        if foreground == COLOR.WHITE and reversed:
            theme.style_bars = theme.style_icons = reversed + curses.A_REVERSE + curses.A_BOLD
        if foreground == COLOR.BLACK:
            theme.style_main = background + curses.A_REVERSE + curses.A_DIM
            theme.style_playing = theme.style_main
    elif color == COLOR.BLACK:
            theme.style_main = COLOR.BLACK_ON_MAGENTA + curses.A_REVERSE + curses.A_DIM
            theme.style_playing = theme.style_main
            theme.style_icons = theme.style_header = COLOR.MAGENTA_ON_BLACK + curses.A_BOLD
            theme.style_selected = COLOR.MAGENTA_ON_BLACK + curses.A_REVERSE + curses.A_BOLD

def make_theme_4(alt):
    app.themes[4] = Theme(\
        style_main = alt or COLOR.RED,
        style_header = (alt or COLOR.RED) + curses.A_BOLD,
        style_bars = alt or COLOR.RED,
        style_selected = (alt or COLOR.RED) + curses.A_BOLD + curses.A_UNDERLINE,
        style_playing = (alt or COLOR.RED) + curses.A_BOLD,
        style_icons = (alt or COLOR.RED) + curses.A_BOLD)

def make_theme_5(alt):
    app.themes[5] = Theme(\
        style_main = COLOR.WHITE + curses.A_DIM,
        style_header = (alt or COLOR.YELLOW),
        style_bars = (alt or COLOR.YELLOW) + curses.A_BOLD,
        style_selected = (alt or COLOR.YELLOW) + curses.A_REVERSE,
        style_playing = (alt or COLOR.WHITE) + curses.A_BOLD,
        style_icons = (alt or COLOR.YELLOW) + curses.A_BOLD)
    if alt and not alt in app.single_colors:
        app.themes[5].style_icons = COLOR.WHITE + curses.A_BOLD
        app.themes[5].style_playing = COLOR.WHITE + curses.A_BOLD

def make_theme_6(alt):
    app.themes[6] = Theme(\
        style_main = COLOR.WHITE + curses.A_DIM,
        style_header = (alt or COLOR.BLACK_ON_WHITE) + curses.A_REVERSE,
        style_bars = (alt or COLOR.BLUE_ON_YELLOW) + curses.A_REVERSE + curses.A_DIM,
        style_selected = (alt or COLOR.YELLOW_ON_BLACK) + curses.A_REVERSE + curses.A_NORMAL,
        style_playing = (alt or COLOR.WHITE) + curses.A_NORMAL,
        style_icons = (alt or COLOR.WHITE) + curses.A_BOLD)
    if alt:
        theme = app.themes[6]
        if not alt in app.single_colors:
            theme.style_header = COLOR.BLACK_ON_WHITE + curses.A_REVERSE
            theme.style_playing = COLOR.WHITE + curses.A_NORMAL
            theme.style_icons = COLOR.WHITE + curses.A_BOLD
            foreground, background = split_colors(alt)
            if foreground == COLOR.WHITE:
                theme.style_selected = theme.style_bars - (curses.A_REVERSE + curses.A_DIM) + curses.A_BOLD
        else:
            color_string = get_dict_key(alt)
            try:
                newcolor = COLOR.map[f"{color_string}-on-black"]
                theme.style_header = newcolor + curses.A_BOLD
            except KeyError:
                pass
        if alt == COLOR.RED_ON_BLUE:
            theme.style_header = COLOR.WHITE_ON_BLACK + curses.A_BOLD
            theme.style_bars = COLOR.RED_ON_BLUE + curses.A_REVERSE + curses.A_DIM
            theme.style_selected = COLOR.WHITE_ON_BLUE
        elif alt == COLOR.GREEN_ON_BLACK:
            theme.style_header = COLOR.GREEN_ON_BLACK + curses.A_BOLD
            theme.style_bars = COLOR.GREEN_ON_BLACK + curses.A_REVERSE + curses.A_DIM
            theme.style_selected = COLOR.BLACK_ON_YELLOW
            theme.style_icons = COLOR.YELLOW + curses.A_BOLD
        elif alt == COLOR.YELLOW_ON_BLUE:
            theme.style_bars = COLOR.BLUE_ON_YELLOW + curses.A_REVERSE + curses.A_DIM
            theme.style_selected = COLOR.BLACK_ON_YELLOW 

def make_theme_7(alt):
    app.themes[7] = Theme(\
        style_main = COLOR.BLACK_ON_WHITE + curses.A_DIM,
        style_header = COLOR.WHITE_ON_BLACK,
        style_bars = (alt or COLOR.CYAN_ON_WHITE) + curses.A_REVERSE + curses.A_DIM,
        style_selected = (alt or COLOR.CYAN_ON_WHITE) + curses.A_REVERSE + curses.A_BOLD,
        style_playing = COLOR.BLACK_ON_WHITE + curses.A_BOLD,
        style_icons = COLOR.BLACK_ON_WHITE + curses.A_NORMAL)
    theme = app.themes[7]
    if alt and alt in app.single_colors:
        if alt == COLOR.WHITE:
            theme.style_selected = COLOR.WHITE_ON_BLACK + curses.A_BOLD
        else:
            try:
                ctext = get_dict_key(alt)
                ctext = f"white-on-{ctext}"
                color = COLOR.map[ctext]
                theme.style_selected = color + curses.A_BOLD
            except KeyError:
                pass
    elif alt:
        foreground, background = split_colors(alt, return_text = True)
        if foreground == "white":
            theme.style_selected = alt + curses.A_BOLD
            newcolor = COLOR.map[f"{background}-on-{foreground}"]
            theme.style_icons = theme.style_playing = newcolor + curses.A_BOLD

def make_theme_8(alt):
    app.themes[8] = Theme(\
        style_main = COLOR.BLACK_ON_WHITE + curses.A_BOLD,
        style_header = (alt or COLOR.MAGENTA_ON_WHITE) + curses.A_REVERSE + curses.A_BOLD,
        style_bars = (alt or COLOR.MAGENTA_ON_WHITE) + curses.A_REVERSE + curses.A_BOLD,
        style_selected = (alt or COLOR.MAGENTA_ON_WHITE) + curses.A_REVERSE + curses.A_BOLD,
        style_playing = COLOR.BLACK_ON_WHITE + curses.A_BOLD + curses.A_UNDERLINE,
        style_icons = COLOR.BLACK_ON_WHITE + curses.A_BOLD)
    if alt and alt in app.single_colors:
        app.themes[8].style_bars = alt

def convert_to_curses(value):
    value = value.replace(' ', '').replace('_','-').lower()
    styles = value.split('+')
    color = styles[0]
    styles = styles[1:4] ##updated to support 3 styles
    try:
        color = COLOR.map[color]
    except KeyError:
        color = 0
        app.send_msg("Error loading custom theme")
    curses_style = color
    if styles:
        for i, key in enumerate(styles):
            try:
                styles[i] = app.style_map[key]
                curses_style += styles[i]
            except KeyError:
                app.send_msg("Error loading custom theme")
    return curses_style

def change_theme(theme, msg = True):
    app.theme_index = theme
    if not app.settings["use_color"]: return
    try:
        app.theme = app.themes[theme]
    except KeyError:
        app.theme = app.themes[0]
        app.send_msg(f"Error: Theme {theme} does not exist")
        msg = False
    app.updated = True
    if msg: app.send_msg(f"Theme {theme}")

def cycle_colors(n):
    if not app.settings["use_color"]:
        app.send_msg("Can't change color in monochrome mode")
        return
    if type(n) is int:
        app.color_index += n
        if app.color_index < 0: app.color_index = len(app.gui_colors) - 1
        if app.color_index >= len(app.gui_colors): app.color_index = 0
    elif n in app.gui_colors:
        app.color_index = app.gui_colors.index(n)
    app.settings["color_override"] = app.gui_colors[app.color_index]
    app.send_msg(f"Color override = {app.gui_colors[app.color_index]}")
    if khaos_playing():
        screensaver.theme_colors = get_theme_colors(singles_only = True)
        override = get_alt_or_main_color()
        screensaver.theme_colors.append(override)
        screensaver.color = override #change screensaver color
    elif plankton_playing() or tetragon_playing():
        screensaver.reset = True
    make_themes()
    change_theme(app.theme_index, msg = False)

def append():
    """Append all marked items or selected item if nothing marked.
    Can also load entire directory with sub directories."""
    unfilter_playlist()
    marked = append_marked()
    if not marked:
        obj = app.all[app.index]
        if not is_file(obj):
            append_directory(obj) #import dirs and sub-dirs
        else:
            append_selected(obj)

def append_marked():
    marked = 0
    size = len(app.files)
    for i, item in enumerate(app.files):
        show_load_progress(i, size)
        if item.marked:
            item.marked = False
            new_item = copy.deepcopy(item)
            if item.is_midi and app.midi_config:
                new_item.midi_config = app.midi_config
            app.playlist_main.append(new_item)
            marked += 1
    if marked:
        app.send_msg(f"{marked} file(s) added", 1)
    return marked

def append_directory(item):
    if confirmation("Add ENTIRE directory tree to Playlist? (y/n) "):
        cprint("   Processing...", x=-16,y=0,style = app.theme.style_header)
        screen.refresh()
        try:
            path = item.fullpath
        except AttributeError:
            path = Path.cwd()
            if str(path.expanduser()).count('/') < 3: #keep from importing entire home dir
                app.send_msg("Error: Operation not allowed")
                return
        #objects = tuple(path.glob("**/*")) #I believe this was too damn slow
        objects = [file for file in get_files(path)]
        size = len(objects)
        app.timeout = Alarm(20)
        app.playlist_main.extend([appended(i, item, size) for i,\
            item in enumerate(objects) if not item.is_dir() and is_av(item)\
            and not str(item).endswith("m3u")])
        app.send_msg(f"{len(app.playlist_main)} file(s) added", 2)

def appended(i, item, size):
    #if not i % 1000:
    show_load_progress(i, size)
    f = Path(Path.cwd()/Path(item))
    obj = FileObj(f, hidden = True)
    if app.timeout and not app.timeout(): #if timeout exists, but timeout time not reached
        get_metadata(obj, default_album = obj.path.parent.name)
    else:
        app.timeout = None

    if app.settings["get_meta_with_ffprobe"]:
        if not obj.is_midi and not obj.is_stream and not obj.ext == "m3u":
            app.playlist_to_probe.append(obj)
    return obj

def get_files(folder): #pass string, returns Generator
    if not type(folder) is str: folder = str(folder)
    try:
        with os.scandir(folder) as scan:
            for item in scan:
                if item.is_file():
                    yield item
                else:
                    for subitem in get_files(item.path):
                        yield subitem
    except PermissionError:
        app.send_msg("Error, Permission Denied")
        return
    except FileNotFoundError:
        app.send_msg("Error, file or directory does not exist")

def append_selected(item):
    new_item = copy.deepcopy(item)
    if item.ext == "mid" and app.midi_config:
        new_item.midi_config = app.midi_config
    if item.ext == "m3u":
        play_handler()
        return
    app.playlist.append(new_item)
    app.send_msg("File added", .6)

def show_load_progress(n, size, text = "LOADING", mod_value = 250, min_size = 1500):
    if n % mod_value: return
    if size < min_size: return
    pos = int(n/size*100)
    cprint(f"{text}: {pos}% ".rjust(screen.getmaxyx()[1]), x=0, y=0, color = app.theme.style_header)
    cprint("Please wait...", x=0, y=0, color = app.theme.style_header)
    draw_progress_bar(pos, y = 1, color = app.theme.style_bars)
    screen.refresh()

def show_copy_progress(n, size, text = "COPYING"):
    pos = int(n/size*100)
    cprint(f"{text}: {pos}% ".rjust(screen.getmaxyx()[1]), x=0, y=0, color = app.theme.style_header)
    cprint("Please wait...", x=0, y=0, color = app.theme.style_header)
    draw_progress_bar(pos, y = 1, color = app.theme.style_bars)
    screen.refresh()

def mark():
    if app.mode == "playlist":
        files = app.playlist
        index = app.playlist_index
    else:
        files = app.all
        index = app.index
    try:
        item = files[index]
    except IndexError:
        return
    if type(item) is str or item.ext == "m3u":
        app.send_msg("Error: You can't mark playlists")
        return
    if item.is_dir: return
    item.marked = not item.marked
    index += 1
    if index >= len(files):
        index = 0 if app.mode == "playlist" else 1
    if app.mode == "playlist":
        app.playlist_index = index
    else:
        app.index = index

def unmark_all():
    if app.mode == "playlist":
        files = app.playlist
    else:
        files = app.all
    for f in files:
        if is_file(f):
            f.marked = False
    app.send_msg("All files unmarked")

def search_for_duplicates():
    if not app.mode == "playlist": return
    import filecmp
    unmark_all()
    total = 0
    count = len(app.playlist)
    obj = app.playlist[app.playlist_index]
    for i, file1 in enumerate(app.playlist):
        show_load_progress(i, count, "Searching for Duplicates", mod_value = 20, min_size = 60)
        if not file1.marked:
            file1.flagged = True
        for file2 in app.playlist:
            if not file2.flagged and filecmp.cmp(file1.fullpath, file2.fullpath, shallow = False):
                file2.marked = True
                total += 1
    app.playlist_filter = "duplicates"
    filter_playlist(by_marked = True)
    app.send_msg(f"{len(app.playlist_filtered)} duplicate(s) found!", 4)

def inverse_selection():
    if app.mode == "playlist":
        files = app.playlist
    else:
        files = app.files
    for item in files:
        if item.name.lower().endswith("m3u"):
            continue #do not mark playlists
        item.marked = not item.marked
    app.send_msg("Selection inverted")

def search_and_mark(search):
    search = search.lower()
    if app.mode == "playlist":
        files = app.playlist
    else:
        files = app.all
    count = 0
    for file in files:
        if type(file) is str or file.ext == "m3u": continue
        if any((search in file.name.lower(), search in file.title.lower(),\
        search in file.artist.lower(), search in file.album.lower())):
            file.marked = True
            count += 1
        else:
            file.marked = False
    return f"{count} file(s) marked"

def delete_from_playlist():
    if not app.mode == "playlist" or not len(app.playlist_main): return False #changed
    if app.settings["confirm_before_delete"] and not confirmation("Delete file(s) from playlist? (y/n)"):
        return
    count = 0
    p = []
    for i, item in enumerate(app.playlist_main): #delete marked
        if not item.marked:
            p.append(item)
        else:
            item.marked = False
            count += 1
    if count:
        app.playlist_main = p
        app.send_msg(f"{count} file(s) removed")
    else:
        app.playlist_main.pop(app.playlist_index) #delete selected
        app.send_msg("1 file removed")
    app.playlist = app.playlist_main
    if app.playlist_filtered and app.playlist: #refilter playlist if necessary
        filter_playlist()
    else:
        app.playlist_filter = ''

def move_entry_down():
    stop()
    index1 = app.playlist_index
    item1 = app.playlist[index1]
    index2 = app.playlist_index + 1
    if index2 >= len(app.playlist): #insert entry at beginning
        index2 = 0
        app.playlist.insert(0, app.playlist.pop(-1))
    else: #swap position with item beneath it
        item2 =  app.playlist[index2]
        app.playlist[index1], app.playlist[index2] = app.playlist[index2], app.playlist[index1]
    app.playlist_index += 1
    app.send_msg(f"File position changed to {index2+1}")

def move_entry_up():
    stop()
    index1 = app.playlist_index
    item1 = app.playlist[index1]
    index2 = app.playlist_index - 1
    if index2 < 0: #insert at end
        index2 = len(app.playlist) - 1
        app.playlist.insert(len(app.playlist)-1, app.playlist.pop(0))
    else: #swap position with item above it
        item2 =  app.playlist[index2]
        app.playlist[index1], app.playlist[index2] = app.playlist[index2], app.playlist[index1]
    app.playlist_index -= 1
    app.send_msg(f"File pos changed to {index2+1}")

def filter(filter = None):
    if app.mode == "help": return False
    if filter is None:
        try:
            filter = get_text(allow_spaces = True, additional_chars = '=!').lower()
        except AttributeError:
            return
    if app.mode == "playlist":
        app.playlist_index = 0
        app.playlist_filter = filter
        if app.playlist_filter:
            filter_playlist()
        else:
            unfilter_playlist()
    else:
        if app.filter:
            unfilter_filelist()
        app.index = 0
        app.filter = filter
        if app.filter:
            filter_filelist()
        else:
            unfilter_filelist()

def filtered(item):
    if type(item) is str or all((not app.filter, not app.playlist_filter)): return True
    if app.mode == "playlist":
        filter = app.playlist_filter
    else:
        filter = app.filter

    if "!" in filter:
        field, filter = filter.split('!')
        filter = filter.replace('!', '').replace('=','').strip()
        for f in ("name", "title", "album", "artist", "year", "genre", "ext", "path"):
            if f == field and filter not in str(getattr(item, f)).lower():
                return True
        return False
    elif "=" in filter:
        field, filter = filter.split('=')
        filter = filter.replace('=', '')
        for f in ("name", "title", "album", "artist", "year", "genre", "ext", "path"):
            if f == field and filter in str(getattr(item, f)).lower():
                return True
        return False

    if filter in item.name.lower(): return True
    if app.list_view == "paths" and filter in str(item.fullpath).lower(): return True
    if app.list_view == "metadata" or str(app.list_view).startswith("custom"):

        for value in (item.title, item.album, item.artist, item.year, item.genre):
            if value is not None and filter in str(value).lower(): return True
    return False

def slow_filter_playlist():
    app.playlist_filtered = []
    count = len(app.playlist_main)
    for i, item in enumerate(app.playlist_main):
        show_load_progress(i, count, "FILTERING")
        if filtered(item):
            app.playlist_filtered.append(item)
    app.playlist = app.playlist_filtered

def filter_playlist(by_marked = False):
    app.playlist_filtered = []
    count = len(app.playlist_main)
    app.send_msg("FILTERING")
    if by_marked or app.playlist_filter == "marked":
        app.playlist_filtered = [item for item in app.playlist_main if item.marked]
    else:
        app.playlist_filtered = [item for item in app.playlist_main if filtered(item)]
    app.playlist = app.playlist_filtered
    app.send_msg("Done!", 1)

def unfilter_playlist():
    app.playlist_filter = ''
    app.playlist_filtered = []
    app.playlist = app.playlist_main

def filter_filelist():
    app.filtered = []
    count = len(app.all)
    for i, item in enumerate(app.all[1:]):
        show_load_progress(i, count, "FILTERING")
        if filtered(item):
            app.filtered.append(item)
    app.files = app.all = app.filtered

def unfilter_filelist():
    app.filter = ''
    app.filtered = []
    app.files = app.files_loaded
    app.all = app.all_loaded

def find(again = False, search_text = None):
    if again:
        search = app.search
    elif search_text:
        search = app.search = search_text
    else:
        search = app.search = get_text("Find: ", allow_spaces = True)
    if not search: return None
    array = app.playlist if app.mode == "playlist" else app.all
    current_index = app.playlist_index if app.mode == "playlist" else app.index
    matches = []
    for i, item in enumerate(array):
        if item == "../": continue
        if (app.list_view == "metadata" or str(app.list_view).startswith("custom")) and not item.is_dir:
        #if app.list_view in ("metadata", "custom1", "custom2")  and not item.is_dir:
            match = item.title.lower() + item.name.lower()
        else:
            match = item.name.lower()
        if search.lower() in match and current_index != i:
            matches.append(i)
    if matches:
        if current_index >= matches[-1]:
            index = matches[0]
        else:
            index = [i for i in matches if i > current_index][0]
        if app.mode == "playlist": app.playlist_index = index
        else: app.index = index
        app.updated = True
        num = len(matches)
        text = "match" if num == 1 else "matches"
        if not again:
            app.send_msg(f"Found {len(matches)} {text}")
    else:
        app.send_msg(f"Item Not Found!")
        index = None
    return index

def goto():
    search = get_text("Goto: ", allow_spaces = True, additional_chars = "~/")
    if not search: return
    if len(search) < 3 or app.mode == "playlist":
        sortby("title", reset = True) #sort results if match found
        array = app.playlist if app.mode == "playlist" else app.all
        for i, item in enumerate(array):
            if item == "../": continue
            if app.list_view == "metadata" or str(app.list_view).startswith("custom") and not item.is_dir:
            #if app.list_view in ("metadata", "custom1", "custom2") and not item.is_dir:
                match = item.title.lower()
            else:
                match = item.name.lower()
            if app.is_streaming and match.startswith("["):
                match = match[1:]
            if match.startswith(search.lower()):
                if app.mode == "playlist": app.playlist_index = i
                else: app.index = i
                app.updated = True
                return

    elif "/" in search:
        path = Path(search).expanduser()
        if path.exists():
            update_directory(Path(search).expanduser())
            msg = "Directory changed"
        else:
            msg = "Error: Directory not found"
        app.send_msg(msg)
        return
    else:
        cmd1 = f'find -H -type d -name "{search}" | head -n 1'
        cmd2 = f'find -H ~/ -type d -name "{search}" | head -n 1'
        with os.popen(cmd1) as p:
            r = p.read()
        r = r.strip()
        if not r:
            with os.popen(cmd2) as p:
                r = p.read()
            r = r.strip()
        if r:
            app.send_msg(f"cd to {search}")
            update_directory(r)
        else:
            app.send_msg("Error: Directory not found")

def export_playlist():
    try:
        if confirmation(f"Export {len(app.playlist)} file(s) in playlist? (y/n)"):
            dir = get_text(f"Enter dir name: ~/Music/mplay_exported/", default_text=app.playlist_name)
            path = Path(f"~/Music/mplay_exports/{dir}")
            if not dir: raise NameError
            append_tracks = confirmation(f"Number files? (y/n)")
        else:
            raise NameError
    except NameError: #path does not exist
        return "Export cancelled"
    try:
        import shutil
    except ModuleNotFoundError:
        msg = "Error: shutil not installed"
    else:
        path = Path(path).expanduser()
        if Path.is_dir(path) and not confirmation("Path exists, overwrite? (y/n)"):
            return "Export cancelled"
        path.mkdir(parents = True, exist_ok = True)
        size = len(app.playlist)
        for i, obj in enumerate(app.playlist):
            if append_tracks:
                fullpath = f"{path}/{str(i+1).zfill(4)} - {obj.path.name}"
            else:
                fullpath = path
            show_copy_progress(i, size)
            shutil.copy2(obj.fullpath, fullpath)
        msg = f"{i+1} file(s) copied"
    return msg

def get_af_cmd(cmd, arg):
    cmap = {
        "lowpass": f"lowpass=f",
        "highpass": f"highpass=f",
        "tempo": f"scaletempo",
        "pitch": f"rubberband=pitch-scale"}
    if arg in (("low","slow","down")):
        arg = .85
    elif arg in (("high", "fast", "up")):
        arg = 1.15
    if cmd in cmap.keys() and str(arg).replace('.', '', 1).isdigit():
        arg = float(arg)
        if cmd in (("tempo", "pitch")):
            arg = min(max(.5, arg), 2)
        else:
            arg = min(max(0, arg), 20000)
        return f"{cmap[cmd]}={arg}", f"Audio Filters: {cmd}={arg}" 
    else:
        return "", "Audio Filters: None"

def get_fx(cmd, arg):
    fx_map = {
        "reverb": "aecho=.8:1:250|500:0.3|0.15",
        "reverb2": "aecho=1:0.9:100|200:0.4|0.2",
        "echo": "aecho=0.8:0.9:1000|1800:0.3|0.25",
        "echo2": "aecho=0.8:0.9:500|1000:0.3|0.25",
        "chorus": "chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3",
        "crystal": "crystalizer=1:0",
        "flanger": "flanger=0:10:0:50",
        "tremolo": "tremolo=4:.5",
        "vibrato": "vibrato=10:0.1",
        "vibrato2": "vibrato=5:.3",
        "tape": "vibrato=3:.3",
        "broken": "vibrato=5000:0.05",
        "exciter": "aexciter=1:0.9:1:5:0:2000:10000",
        "exciter2": "aexciter=1:0.9:1.5:8.5:0:2000:10000",

        "phaser": "aphaser=0.9:0.75:3:0.5:.1:t",
        "phaser2": "aphaser=0.9:0.8:3.5:0.5:.2:t",
        "limiter": "alimiter",
        "tempo-up": "scaletempo=1.15",
        "tempo-down": "scaletempo=.85",
        "pitch-up": "rubberband=pitch-scale=1.166",
        "pitch-down": "rubberband=pitch-scale=.833",
        "lowpass": "lowpass=1000",
        "highpass": "highpass=1000",
        "highcut": "lowpass=8000",
        "lowcut": "highpass=100",
        "normalize": "lavfi=[loudnorm=I=-16:TP=-3:LRA=4]",
        "bitcrush": "acrusher=1:1:8:0.5:log:1:1:10",
        "bitcrush2": "acrusher=1:1:8:0.7:log:1:.5:20",
        "bitcrush3": "acrusher=1:1:4:0.5:log:1:1:1:1:30",
        "grunge": "acrusher=1:1:16:0.2:lin:1:1:1:1:40:50",
        "ear-saver": "equalizer=1500:h:1000:-10",

        "eq-boost-low": "equalizer=150:h:100:6",
        "eq-boost-mid": "equalizer=1500:h:750:6",
        "eq-boost-high": "equalizer=8000:h:2000:6",
        "eq-cut-low": "equalizer=150:h:100:-6",
        "eq-cut-mid": "equalizer=1500:h:750:-6",
        "eq-cut-high": "equalizer=8000:h:2000:-6",
        "widen": "stereowiden=20:0.7:0.3:0.8"
    }

    if '+' in arg:
        fx = ''
        try:
            if arg.count('+') > 3:
                raise OverflowError #Don't chain more than 4 fx!
            args = arg.split('+')
            fx = ','.join(fx_map[key.replace('1', '')] for key in args)
        except KeyError:
            fx = "ERROR"
        except OverflowError:
            fx = "OVERKILL"
    else:
        arg = arg.replace('1', '')
        fx = fx_map.get(arg, '')
    return fx

def reset_saver_overrides():
    screensaver.speed_mod = 1
    screensaver.particle_override = None
    screensaver.bounce = False
    screensaver.laser = False
    screensaver.stars = False
    screensaver.wandering = False

def change_saver(arg):
    arg = str(arg)
    if arg in "12345678":
        arg = "eink modem matrix khaos plankton tetragon rave pixels".split()[int(arg)-1]
    savers = {'0':0, 'off':0, '1':1, 'eink':1, 'on':1, '2':2,
    'modem':2, '3':3, 'matrix':3, '4':4, 'khaos':4,
    '5':5, 'plankton':5, 'now':'PLAY NOW', 'wake':'WAKE NOW',
    'snow': 5, 'bubbles':5, 'frame':4, 'drip':3, 'artist':5,
    'artists':5, 'pixels':5, 'reset':'RESET', 'geometric':4,
    'rave':5, 'random': 'RANDOM', '6':6, 'tetragon': 6,
    'none':0, 'stop':0}

    msg = ''
    screensaver.data = False
    try:
        value = savers[arg]
        if value == "PLAY NOW":
            app.last_touched = -9999
            screensaver.engine = screensaver.engine or 1
            app.screensaver_running = True
        elif value == "WAKE NOW":
            app.last_touched = time.time()
            app.screensaver_running = False

            screensaver.data = None
            Particle.data = []
        elif value == "RANDOM":
            screensaver.random = True
            screensaver.engine = 1
            randomize_screensaver()
        else:
            screensaver.random = False
            if screensaver.auto_reset:
                reset_saver_overrides()
        if not value:
            screensaver.random = False
            screensaver.auto_reset = True
            screensaver.engine = 0

        elif arg not in ("wake", "now", "reset", "random"):
            screensaver.engine = value
            screensaver.set(arg)
            c = screensaver.current
            if screensaver.auto_reset:
                screensaver.particle_override = c.particle
                screensaver.bounce = c.bounce
                screensaver.speed_mod = c.speed
                screensaver.laser = c.laser
                screensaver.stars = c.stars
                screensaver.wandering = c.wandering
            screensaver.name = c.name
        msg = f"Screensaver set to {value}"
    except KeyError:
        msg = "Error, bad command"
    return msg

def get_value_from(arg, bool_only = True):
    if arg in ("on", "true", "yes"):
        return True
    elif arg in ("off", "false", "no", "none"):
        return False
    else:
        if bool_only: return False
        else: return arg

def command_entry():
    search = get_text("Enter command: ", allow_spaces = True, additional_chars = "=+:/~!@#$%^&*(){}[]|<>?,", replace={' ':'=', "==":'='}, command_entry = True)
    if not search: return
    app.command_history.append(search)
    if len(app.command_history) > 10:
        app.command_history.pop(1)

    msg = None
    try:
        cmd, arg = search.split('=', 1)
        if not cmd in ("getattr", "particle", "midi", "soundfont"): arg = arg.lower().replace('_', '-')
        if cmd == "particle": arg = arg.replace('_', ' ')
        if cmd == "fps":
            arg = int(arg)
            app.fps = app.settings["fps"] = arg
            if app.fps == 0: app.fps = 1
            msg = f"FPS changed to {arg}"
        elif cmd == "speed":
            if arg in ("off", "false", "none"):
                arg = 1
            arg = float(arg)
            if arg >= 0:
                arg = min(max(.1, arg), 4)
            else:
                arg = max(min(-.1, arg), -4)
            screensaver.speed_mod = arg
            msg = f"Speed mod: {arg}"
        elif cmd == "color" and arg in app.gui_colors:
            cycle_colors(arg)
        elif cmd == "theme":
            arg = int(arg)
            change_theme(arg)
        elif cmd in ["screensaver-time", "time", "n"]:
            app.screensaver_time = max(2, float(arg))
            msg = "Screensaver time changed"
        elif cmd in ("screensaver", "saver", "s"):
            if arg == "random":
                screensaver.random = not screensaver.random
                msg = f"Random saver: {screensaver.random}"
            else:
                msg = change_saver(arg)
        elif cmd in ("playmode", "mode") and arg:
            arg = get_value_from(arg, bool_only = False)
            if not arg:
                arg = "play-all"
            else:
                arg = arg.replace("oneshot", "one-shot").replace("playall", "play-all")
            app.playmode.set(arg)
            msg = f"Play mode: {app.playmode}"
        elif cmd in ("midi", "soundfont"):
            arg = get_value_from(arg, bool_only = False)
            if not arg:
                load_midi_config("none")
            else:
                load_midi_config(str(arg))

        elif cmd == "shuffle":
            shuffle = get_value_from(arg)
            if shuffle:
                shuffle_playlist()
            else:
                sortby("playlist_pos", reset = True)
                restart_playlist_if_needed()
        elif cmd == "search" and arg.startswith("dup"):
            if confirmation("This may take a while, continue? (y/n) "):
                search_for_duplicates()
            else:
                msg = "Command aborted."
        elif cmd == "probe" and arg == "now":
            if app.file:
                app.visible_files_to_probe.append(app.file)
                msg = "File added to probe list"
            else:
                msg = "Error, nothing to probe."

        elif cmd in ("stats", "statbar", "stat-bar"):
            app.show_system_stats = get_value_from(arg)
        elif cmd in ("standout", "entry-standout"):
            app.settings["entry_standout"] = get_value_from(arg)
            msg = f"Entry Standout: {app.settings['entry_standout']}"
        elif cmd in ("dancing", "dancing-errors"):
            app.settings["dancing_errors"] = get_value_from(arg)
            msg = f"Dancing Errors: {app.settings['dancing_errors']}"

        elif cmd == "reverse":
            app.reverse_colors = get_value_from(arg)
            global COLOR
            COLOR = Color()
            msg = f"Reversed colors: {app.reverse_colors}"
        elif cmd == "auto-reset":
            screensaver.auto_reset = get_value_from(arg)
            msg = f"Screensaver auto-reset: {screensaver.auto_reset}"
        elif cmd in ("main", "header", "bars", "selected", "playing", "icons"):
            key = f"style_{cmd}"
            style = convert_to_curses(arg)
            setattr(app.theme, key, style)
            app.theme_overrides[f"custom_theme_style_{cmd}"] = arg
        elif cmd == "delay":
            arg = float(arg)
            arg = min(arg, .05)
            app.settings["app_delay"] = max(arg, .001)
            msg = f"App delay: {app.settings['app_delay']}"
        elif cmd == "stream" and arg and arg.lower().startswith("http") and not app.sync:
            stop()
            app.file = FileObj(arg)
            app.file.is_stream = True
            play_streaming(app.file)
            msg = "Attempting to connect..."
        elif cmd == "export" and arg in ("music", "playlist"):
            if app.playlist:
                msg = export_playlist()
            else:
                msg = "Error: No files in playlist"
        elif cmd == "convert" and arg.startswith("mid"):
            ##-Disabled for now. Buggy and potentially a security risk
            #msg = convert_midi(app.file)
            msg = "Error, experimental feature/not available!"

        elif cmd == "mark" and arg:
            msg = search_and_mark(arg)
        elif cmd == "probelist" and arg == "clear" and\
        confirmation("Clear all probe lists? (y/n)"):
            app.playlist_to_probe = []
            app.visible_files_to_probe = []
            app.filelist_to_probe = []
            msg = "Probe lists cleared"
        elif cmd == "debug":
            app.debug = get_value_from(arg)
            if app.debug and not app.mode == "help": toggle_help()
            if not app.debug and app.mode == "help": toggle_help()
            msg = f"Debug Mode: {app.debug}"
        elif app.debug and cmd == "getattr":
            msg = "Attribute read"
            if "comment" in arg:
                if app.file and app.file.comment:
                    app.debug_output = app.file.comment
            else:
                try:
                    app.debug_output = str(getattr(app, arg))
                except AttributeError:
                    try:
                        app.debug_output = str(getattr(screensaver, arg))
                    except AttributeError:
                        msg = f"'{arg}' not found"

        elif cmd in (("lowpass", "highpass", "tempo", "pitch")) and arg:
            player.af, msg = get_af_cmd(cmd, arg)
        elif cmd in ("af", "audio-filter"):
            arg = get_value_from(arg, bool_only = False)
            if not arg:
                player.af = ''
                msg = "Audio Filters: None"
            else:
                try:
                    player.af = arg
                    msg = "Audio Filter applied"
                except TypeError:
                    msg = "Error, af command not valid"

        elif cmd in ("norm", "normalize"):
            arg = get_value_from(arg)
            if arg:
                arg = "lavfi=[loudnorm=I=-16:TP=-3:LRA=4]"
                msg = "Volume Normalize: True"
            else:
                arg = ''
                msg = "Audio Filters: None"
            player.af = arg
        elif cmd == "fx":
            fx = get_fx(cmd, arg)
            try:
                if fx == "ERROR":
                    msg = "Error, FX combo not valid"
                elif fx == "OVERKILL":
                    msg = "Error, don't chain more than 4 fx"
                elif fx:
                    msg = f"FX = {arg.title().replace('+', ' + ')}"
                else:
                    msg = "Audio Filters: None"
                player.af = fx
            except TypeError:
                msg = "Error, FX not valid"
        elif cmd == "tag":
            if arg in ("title", "album", "artist", "genre", "year"):
                apply_tags(arg)
            else:
                msg = f"Error, '{arg}' isn't supported"

        elif cmd == "screen" and arg == "clear":
            curses.flash(); screen.refresh()
            screen.clear(); screen.refresh()
            msg = "Screen cleared!"
        elif cmd in ("volume", "vol", 'v') and arg:
            volume = int(arg)
            player.volume = app.volume = sorted((volume, 0, 130))[1] #clamp
            if app.midi_is_playing and app.file.is_midi: play_midi(app.file)
            msg = f"Volume: {app.volume}"
        elif cmd == "pause":
            player.pause = get_value_from(arg)
            if player.pause and app.file and app.midi_is_playing: stop()
            elif not player.pause and app.file and app.file.is_midi: play_midi(app.file)
            msg = f"Paused: {player.pause}"
        elif cmd == "play":
            if app.sync:
                msg = "Error, can't play music in SYNC mode!"
            elif arg in ("next", "prev"):
                play_handler(arg)
            elif arg == "stop":
                stop()
            elif arg == "pause":
                toggle_pause()
            else:
                index = find(search_text = arg.replace('-', ' '))
                if index is not None:
                    play(index, isPlaylist = app.playlist_is_playing or app.mode == "playlist")

        elif cmd in ("seek", "skip"):
            try:
                arg = float(arg)*60 #convert to mins
                seek(arg)
            except ValueError:
                msg = "Error, invalid seek value"
        elif cmd == "filter":
            arg = get_value_from(arg, bool_only = False)
            if not arg or arg == "none" or type(arg) is bool:
                filter('')
            else:
                filter(arg)

        elif cmd == "unfilter":
            filter('')
        elif cmd == "find" and arg:
            find(search_text = arg)
        elif cmd in ("sort", "sortby"):
            arg = arg.replace('-', '_')
            if arg in ("reverse", "rev", "r"):
                toggle_reverse()
            elif app.file and not type(app.file) is str and hasattr(app.file, arg):
                sortby(arg, reset = True)
            elif len(FileObj.data) > 1 and hasattr(FileObj.data[1], arg):
                sortby(arg, reset = True)
            else:
                msg = "Error, invalid sort attribute"
        elif cmd in ("kiosk", "kiosk-mode"):
            app.kiosk_mode = get_value_from(arg)
            msg = f"Kiosk Mode: {app.kiosk_mode}"
        elif cmd == "looping" and arg:
            app.looping = get_value_from(arg)
            msg = f"Looping: {app.looping}"
        elif cmd == "elapsed" and arg:
            app.show_remaining = not get_value_from(arg)
            kind = "remaining" if app.show_remaining else "elapsed"
            msg = f"Counting {kind} time"

        elif cmd == "quit" and arg in ("true", "now", "yes"):
            quit(now = True)
        elif cmd == "particle":
            if arg.lower() in ("false", "none", "off", "default"):
                screensaver.particle_override = None

            elif arg.isdigit():
                screensaver.particle_override = chr(int(arg))
            else:
                screensaver.particle_override = arg
            msg = f"Particle Override: {str(screensaver.particle_override)}"

        elif cmd == "bounce":
            screensaver.bounce = get_value_from(arg)
            msg = f"Particle bounce: {screensaver.bounce}"
        elif cmd.startswith("laser"):
            screensaver.laser = get_value_from(arg)
            msg = f"Saver laser: {screensaver.laser}"
        elif cmd == "static":
            app.show_static = get_value_from(arg)
            msg = f"static: {app.show_static}"
        elif cmd in ("pageflip", "scroll"):
            arg = get_value_from(arg)
            if cmd == "scroll": arg = not arg
            app.settings["pageflip"] = arg
            msg = f"pageflip: {app.settings['pageflip']}"

        elif cmd == "stars":
            screensaver.stars = get_value_from(arg)
            msg = f"Saver Stars: {screensaver.stars}"
        elif cmd == "wandering":
            screensaver.wandering = get_value_from(arg)
            screensaver.stars = True
            msg = f"Wandering: {screensaver.wandering}"
        elif cmd in {"list", "view"} and arg:
            views = "names,paths,file info,metadata".split(',')
            if app.custom_views:
                for key in app.custom_views.keys():
                    views.append(key)

            arg = arg.replace('-', ' ')
            if arg in views:
                app.list_view.set(arg)

            else:
                msg = "Error, view does not exist"
        else:
            msg = "Error, command not understood"
    except (ValueError, AttributeError):
        msg = "Error: Invalid Command"
    finally:
        if msg:
            app.send_msg(msg)

def randomize_screensaver():
    screensaver.data = None
    screensaver.randomize()
    c = screensaver.current
    screensaver.name = c.name
    screensaver.engine = c.engine
    if screensaver.auto_reset or not random.randrange(0,7):
        screensaver.speed_mod = c.speed
        screensaver.particle_override = c.particle
        screensaver.stars = c.stars
        screensaver.wandering = c.wandering
        screensaver.laser = c.laser
        screensaver.bounce = c.bounce
    elif screensaver.snow and datetime.datetime.now().month not in (12, 1, 2):
        screensaver.particle_override = chr(random.choice((9630, 9471, 9553, 9642)))
    else: #If saver settings did not reset, tweak settings
        if screensaver.rave:
            screensaver.laser = True
        elif screensaver.frame:
            screensaver.bounce = True
        elif screensaver.tetragon:
            screensaver.stars = True
            screensaver.wandering = True
            if screensaver.particle_override and screensaver.particle_override == ".   .":
                screensaver.particle_override = None
        elif screensaver.matrix:
            screensaver.laser = False
        elif screensaver.khaos:
            screensaver.stars = False
        elif screensaver.drip:
            screensaver.particle_override = chr(9617)
            if random.choice((True, False)):
                screensaver.bounce = True
        elif screensaver.artists:
            if random.choice((True, False)):
                screensaver.particle_override = False

def change_volume(amt):
    volume = int(player.volume - player.volume % 5)
    volume += amt
    player.volume = app.volume = sorted((volume, 0, 130))[1] #clamp
    if app.midi_is_playing and app.file.is_midi:
        play_midi(app.file)
    app.send_msg(f"Volume: {app.volume}")

def open_app(alt = False):
    if app.mode == "playlist":
        file = app.playlist[app.playlist_index]
    else:
        file = app.all[app.index]    
    if not is_file(file): return
    if file.ext == "m3u": return
    if file.ext == "mid":
        msg = "Open w/ (a)udacity, (l)mms, (m)ilkytracker or (c)ancel?"
    else:
        msg = "Open w/ (a)udacity, (m)ilkytracker or (c)ancel?"
    choice = get_choice(msg, color = app.theme.style_header)
    if choice not in "AaLlMm": return
    if choice in "Ll" and not file.ext == "mid": return
    if choice in "Aa":
        command = "audacity"
        flag = None
    elif choice in 'Ll':
        command = "lmms"
        flag = "--import"
        if not file.ext == "mid":
            app.send_msg("Error: File is not MIDI")
            return
    else:
        command = "milkytracker"
        flag = "-nosplash"
    if app.mode == "playlist":
        fullpath = app.playlist[app.playlist_index].fullpath
    else:
        fullpath = app.all[app.index].fullpath

    app.send_msg(f"Opening file in {command.capitalize()}")
    if app.midi_is_playing: kill_midi()
    player.pause = True
    app.updated = True
    if flag:
        run(command, flag, fullpath)
    else:
        run(command, fullpath)

def open_image():
    """Loads cover art for SELECTED file, not file playing"""
    try:
        if app.mode == "playlist" and app.playlist:
            item = app.playlist[app.playlist_index]
        elif app.mode == "filelist":
            item = app.all[app.index]
        f = app.music_tag.load_file(item.fullpath)
        artwork = f['artwork']
        if not artwork: raise Exception
        for art in artwork.values:
            image = art.thumbnail([1024,1024])
            image.show()
    except Exception:
        app.send_msg("No images found")
        return

def run(cmd, *args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL):
    try:
        #s = subprocess.Popen([cmd, *args], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        s = subprocess.Popen([cmd, *args], stdout=stdout, stderr=stderr)
        return s
    except (subprocess.CalledProcessError, UnicodeDecodeError, FileNotFoundError):
        app.send_msg(f"Error: {cmd.capitalize()} could not be opened!")

def detect_capslock():
    if not app.settings["detect_capslock"]:
        return False
    try:
        cmd = "xset -q | grep Caps"
        pipe = subprocess.Popen(cmd, shell=True, bufsize=200, stdout=subprocess.PIPE)
        stdout = str(pipe.stdout.readline())
        pipe.stdout.close()
        if "Caps Lock:   on" in stdout: raise Exception
    except Exception:
        return True
    else:
        return False

def erase_playlist():
    if app.settings["confirm_before_delete"] and not confirmation("Erase playlist? (y/n)"):
            return
    if app.playlist_is_playing:
        stop()
    app.playlist_filtered = app.playlist = app.playlist_main = []
    app.playlist_filter = ''
    app.playlist_index = 0
    app.playlist_shuffled = False
    app.playlist_reversed = False
    app.playlist_name = ''
    app.playlist_to_probe = []
    app.send_msg("Playlist erased")

def write_playlist():
    if not app.playlist: return
    if not confirmation("Save playlist? (y/n)"):
        return
    name = get_text("Enter filename: ", default_text = app.playlist_filename)
    if not name: return
    filename = Path(f"~/.config/mplay/playlists/{name}.m3u").expanduser()
    if filename.exists() and not confirmation("Overwrite file? (y/n)"):
        app.send_msg("Save canceled")
        return
    dirname = Path(filename).parent
    dirname.mkdir(parents = True, exist_ok = True)

    if app.playlist_name:
        pname = app.playlist_name
    else:
        pname = filename.stem
    with open (filename, 'w') as f:
        f.write("#EXTM3U\n")
        f.write(f"#PLAYLIST:{pname}\n")
        f.write(f"#{'-' * 40}\n")
        pos = 1
        for item in app.playlist:
            if item.is_midi and item.midi_config:
                config = f'#MIDICONFIG:"{item.midi_config}"\n'
                f.write(config)
            fullpath = f"{item.fullpath}\n"
            f.write(fullpath)
            item.playlist_pos = pos
            pos += 1
    app.send_msg("Playlist saved to .config/mplay")
    app.playlist_name = name

def load_playlist(obj):
    cprint("      Loading...", x=-16,y=0,style = app.theme.style_header)
    screen.refresh()
    app.playlist_to_probe = []
    app.is_streaming = False
    app.stream_file = None
    fullpath = obj.fullpath
    data = None
    try:
        with open(fullpath, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        app.send_msg("Error, File not Found")
        return
    data = [line.rstrip() for line in lines]
    app.playlist_main = []
    prev_name = app.playlist_name
    app.playlist_name = None
    if player.volume > 100 or app.volume > 100:
        player.volume = app.volume = 100

    item_volume = None
    midi_config = None
    count = len(data)
    probe_list = []
    prev = None
    load_aborted = False
    pos = 1
    for i, item in enumerate(data):
        if i: prev = data[i-1]
        show_load_progress(i, count)
        if item.startswith("#PLAYLIST:"):
            app.playlist_name = item.split(":", 1)[1].strip()
            continue
        try:
            if item and not item.startswith("#"):
                o = FileObj(item, hidden = True)
                if o.is_midi:
                    try:
                        o.midi_config = Path(midi_config).expanduser() ##To bugfix
                    except TypeError:
                        midi_config = None
                o.volume = item_volume
                o.playlist_pos = pos
                pos += 1

                if app.show_tags: get_metadata(o, default_album = o.path.parent.name)
                if app.settings["get_meta_with_ffprobe"] and not o.is_midi and not o.is_stream:
                    probe_list.append(o)
                app.playlist_main.append(o)
                item_volume = None 
                midi_config = None
                if prev and (prev.startswith("#NAME:") or prev.startswith("#TITLE:")):
                    o.name = o.title = prev.split(":", 1)[1].strip()
                    o.sort_name = o.name.lower()
                elif prev and prev.startswith("#EXTINF:"):
                    if "group-title=" in prev:
                        title = prev.split("group-title=", 1)[1]
                        o.name = o.title = title
                        o.sort_name = title.lower()
                    elif "," in prev:
                        title = prev.split(",", 1)[1]
                        o.name = o.title = title
                        o.sort_name = title.lower()

            elif item.startswith("#MIDICONFIG:"):
                midi_config = item.split(':', 1)[1].strip()
                if midi_config and midi_config[0] in ("'", '"'):
                    midi_config = midi_config.strip(midi_config[0]) #added to fix bug

                if '/' not in midi_config:
                    midi_config = f"~/.config/mplay/timidity/{midi_config}"
                if not Path(midi_config).expanduser().exists():
                    midi_config = None
            elif item.startswith("#VOLUME:"):
                try:
                    item_volume = min(130, int(item.split(':', 1)[1].strip()))
                except ValueError:
                    item_volume = None
        except (FileNotFoundError, PermissionError) as e:
            app.send_msg(f"Error loading playlist: '{type(e).__name__}'", 4)
            app.playlist_name = prev_name
            stop()
            return
        if count > 1000 and stop_loading():
            load_aborted = True
            break
    if probe_list and app.settings["get_meta_with_ffprobe"]:
        app.playlist_to_probe = probe_list

    if not app.playlist_name:
        app.playlist_name = Path(obj.name).stem

    app.playlist_filename = Path(obj.name).stem #new
    app.playlist = app.playlist_main
    app.mode = "playlist"
    if not load_aborted:
        msg = "Playlist loaded"
    else:
        msg = "LOAD ABORTED, but partial playlist loaded"
    app.send_msg(msg)
    app.playlist_is_playing = True
    app.playlist_index = 0
    play_playlist(0)

def shuffle_playlist():
    from random import shuffle
    shuffle(app.playlist)
    restart_playlist_if_needed()
    app.playlist_shuffled = True
    app.send_msg("Shuffled playlist")

def restart_playlist_if_needed():
    restart = app.playlist_is_playing
    app.playlist_index = 0
    if restart:
        play_playlist()

def change_screensaver_by_key(char):
    n, title = {'!':(1, "   'eink'"), '#':(3, "  'matrix'"), '$': (4, "   'khaos'"),
    '@': (2, "   'modem'"), '%': (5, "'plankton'"), '^': (6, "'tetragon'"),
    '&': (7, "    'rave'"), '*': (8, "  'pixels'")}[char]
    screensaver.data = None
    current = screensaver.current.name
    chosen = title.replace("'","").strip()
    if chosen == current and screensaver.engine:
        msg = f"Screensaver Off "
        screensaver.random = False
        screensaver.auto_reset = True
        change_saver(0)
    else:
        change_saver(chosen)
        msg = f"Screensaver {n}: {title} "
    app.send_msg(msg)

def toggle_remaining():
    app.show_remaining = not app.show_remaining
    kind = "remaining" if app.show_remaining else "elapsed"
    app.send_msg(f"Counting {kind} time")

def toggle_reverse():
    if app.mode == "playlist": ##why are we doing diff sort for playlist???
        app.playlist_reversed = not app.playlist_reversed
        if app.sort:
            app.playlist = sorted(app.playlist, key=operator.attrgetter(app.sort), reverse = app.playlist_reversed)
            msg = f"Sortby: {app.sort} {app.rd[app.playlist_reversed]}"
        else:
            app.playlist = sorted(app.playlist, key=operator.attrgetter("sort_name"), reverse = app.playlist_reversed)
            msg = f"Sortby: name {app.rd[app.playlist_reversed]}"
        app.playlist_shuffled = True
        app.send_msg(msg)
    else:
        app.reverse = not app.reverse
        app.send_msg(f"Sortby: {app.sort} {app.rd[app.reverse]}")
        update_filelist()

def toggle_list(prev = False):
    if prev:
        app.list_view.prev()
    else:
        app.list_view.next()
    app.send_msg(f"Listing {app.list_view}")

def sortby(newsort, reset = None, msg = True):
    if newsort == "title":
        newsort = "sort_title"
        if not app.list_view == "metadata" and not str(app.list_view).startswith("custom"):
        #if not app.list_view in ("metadata", "custom1", "custom2"): #new
            newsort = "sort_name"
        else: #These 2 lines added to fix bug with Title sort, unsure why it was needed
            app.playlist = sorted(app.playlist, key=operator.attrgetter("sort_name"), reverse = False)
    elif newsort == "duration":
        newsort == "duration_raw"

    if app.mode == "playlist":
        app.playlist_index = 0
        if not app.playlist_shuffled and app.sort == newsort and not reset:
            app.playlist_reversed = not app.playlist_reversed
        else:
            app.playlist_reversed = False
        app.sort = newsort
        app.playlist = sorted(app.playlist, key=operator.attrgetter(app.sort), reverse = app.playlist_reversed)
        #restart_playlist_if_needed() #maybe delete_code() if not needed!
        app.playlist_shuffled = False
        app.send_msg(f"Sortby: {app.sort.replace('sort_name', 'name')} {app.rd[app.playlist_reversed]}")
    else:
        app.index = 0
        if app.sort == newsort and not reset:
            app.reverse = not app.reverse
        app.sort = newsort
        if msg:
            app.send_msg(f"Sortby: {app.sort.replace('sort_name', 'name')} {app.rd[app.reverse]}")
        update_filelist()
    target = app.playlist if app.playlist_is_playing else app.all
    if app.file_object_playing and target:
        try:
            app.index_playing = target.index(app.file_object_playing)
        except ValueError:
            pass
    if app.playlist_is_playing:
        app.playlist_index = 0
    else:
        app.index = 0

def toggle_pause():
    if app.file and is_file(app.file, ext = "mid"):
        if app.midi_is_playing:
            kill_midi()
        else:
            play_playlist()
    else:
        player.pause = not player.pause

def play_or_pause():
    if app.mode == "playlist":
        item = app.playlist[app.playlist_index]
    elif app.mode == "filelist":
        item = app.all[app.index]
    else:
        return
    if type(item) is str or item.is_dir:
        file_is_playable = False
    else:
        file_is_playable = True

    if file_is_playable and key.repeating and app.key_available():
        play_handler()
        app.key_available = Alarm(1.2)
    elif (player.filename or app.midi_is_playing) and not key.repeating:
        toggle_pause()
    elif app.key_available():
        if file_is_playable:
            play_handler()
        else:
            play_handler("next")

def stop():
    player.stop()
    app.index_playing = 0
    if app.midi_is_playing:
        kill_midi()
    app.playlist_is_playing = False
    app.file_object_playing = None
    app.is_streaming = False
    app.stream_file = None
    if app.master:
        save_sync_data()

def toggle_playlist():
    app.last_mode = app.mode
    if app.mode == "filelist":
        app.mode = "playlist"
    else:
        app.mode = "filelist"

def toggle_help():
    if app.mode == "help":
        app.mode, app.lastmode = app.lastmode, app.mode
        app.debug_output = None
    else:
        app.lastmode = app.mode
        app.mode = "help"
    app.playlist_duration = 0
    app.playlist_size = 0

def update_logic():
    if app.thread_error:
        app.error = app.thread_error
        quit(now = True)

    if (app.show_static or app.is_probing) and app.update_time():
        app.updated = True
        app.update_time = Alarm(1/app.fps)

    if app.sync and app.sync_time():
        load_sync_data()
        app.sync_time = Alarm(.1)

    app.is_probing = False
    if not app.mode == "help" and screensaver.engine and app.last_touched + app.screensaver_time < time.time():
        app.screensaver_running = True
    else:
        app.screensaver_running = False
        screensaver.data = None
        Particle.data = []

    if app.playlist and app.playlist_is_playing:
        if app.playlist_index < 0: 
            app.playlist_index = len(app.playlist) - 1
        if app.playlist_index >= len(app.playlist): 
            app.playlist_index = 0

    if app.is_streaming:# or app.stream_file:
        get_streaming_metadata()

    if not app.current_file == player.filename:
        app.current_file = player.filename
        app.updated = True
    if app.has('alarm') and app.alarm and app.alarm(): #if alarm has gone off, delete it and clear msg
        app.msg = None
        app.updated = True
        del(app.alarm)
    if app.midi_is_playing and app.midi_process and app.midi_process.poll() is not None:
        app.midi_is_playing = False
        app.midi_filename = ''
        app.updated = True
    if not player.filename and app.playing and not app.midi_is_playing:
        if app.is_streaming:
            reconnect_stream()
        elif app.playlist_is_playing:
            if len(app.playlist) and not app.playmode == "one-shot":
                play_playlist("next", user_input = False)
            else:
                if not app.playmode == "one-shot": #added this to try and stop bug
                    app.playlist_is_playing = False #stop playing playlist if empty        
                app.file_object_playing = None

        elif len(app.files):
            app.playing = False
            app.updated = True
            if app.master: save_sync_data()
        if screensaver.random and not app.is_streaming:
            randomize_screensaver()

def reconnect_stream():
    if app.file:
        play_streaming(app.file)
        app.send_msg("Lost stream, reconnecting...")
    else:
        app.send_msg("Error: Stream Disconnected")
        stop()

def eink_playing():
    return True if app.screensaver_running and screensaver.engine == 1 else False

def modem_playing():
    return True if app.screensaver_running and screensaver.engine == 2 else False

def matrix_playing():
    return True if app.screensaver_running and screensaver.engine == 3 else False

def khaos_playing():
    return True if app.screensaver_running and screensaver.engine == 4 else False

def plankton_playing():
    return True if app.screensaver_running and screensaver.engine == 5 else False

def tetragon_playing():
    return True if app.screensaver_running and screensaver.engine == 6 else False

def true_savers_playing():
    """True savers are distration free screensavers that don't draw headers"""
    return any((matrix_playing(), khaos_playing(), plankton_playing(), tetragon_playing()))

def draw_screen():
    if app.screensaver_running:
        if app.screensaver_update_time():
            screen.erase()
            if screensaver.engine == 3: #don't draw main for the Matrix
                draw_saver_matrix()
            elif screensaver.engine == 4:
                draw_saver_khaos()
            elif screensaver.engine == 2:
                draw_saver_slow_modem()
                if screensaver.laser: draw_laser(vertical = False)
            elif screensaver.engine == 5:
                draw_saver_plankton()
            elif screensaver.engine == 6:
                draw_saver_tetragon()

            else:
                draw_main()
                if screensaver.laser: draw_laser(vertical = False)
            app.screensaver_update_time = Alarm(1/app.fps)
    else:
        screen.erase()
        draw_main()

    if not true_savers_playing() and (not app.show_system_stats or not app.screensaver_running):
        draw_header()
        draw_status() #moved after main to fix index bug
    else:
        draw_stat_bar()

    draw_footer()
    screen.refresh()

def draw_header():
    for n in (1,-2): #draw seperators
        draw_hline(x = 0, y = n, style = app.theme.style_bars)

#    ##Temp for debug purposes
#    if app.mode == "playlist":
#        index = app.playlist_index
#    else:
#        index = app.index
#    cprint(f"Index: {index}        Range: {app.chooser_range}", x = 0, y = 0)
#    return

    if modem_playing():
        if app.file and type(app.file) is not str and not app.file.is_dir:
            if app.is_streaming or app.file.is_stream: ##new bit
                text = app.file.name
            else:
                try:
                    filepath = Path(app.file.fullpath)
                    text = str('~' / filepath.relative_to(Path.home()))
                except ValueError:
                    text = str(app.file.fullpath)

            cprint(f"{text} ", 0, 0, style = app.theme.style_header, fill = True) ##Draw file path

    elif app.mode == "filelist":
        if app.filter:
            cprint(f"Filelist: filtered by '{app.filter}' ", x=0, y=0, fill = True, style = app.theme.style_header)
        else:
            cprint(f"Filelist: {app.cwd} ", x = 0, y = 0, fill = True, style = app.theme.style_header)
    elif app.mode == "playlist":
        if app.playlist_filter:
            cprint(f"Playlist: filtered by '{app.playlist_filter}' ", x=0, y=0, fill = True, style = app.theme.style_header)
        else:
            cprint(f"Playlist: {app.playlist_name} ", x = 0, y = 0, fill = True, style = app.theme.style_header)
    else:
        if app.debug:
            cprint("!!! DEBUG MODE !!! ", x = 0, y = 0, fill = True, style = app.theme.style_header)
        else:
            cprint("Help ", x = 0, y = 0, fill = True, style = app.theme.style_header)
    ##debug only
    #cprint(f"Threads: {threading.active_count()}  ", x = 0, y = 0)

def draw_status():
    if app.msg:
        msg = f"   {app.msg}"
        if app.settings["dancing_errors"] and "Error" in app.msg and random.randrange(0,4) == 1:
            msg = msg.upper()
        cprint(msg, x=-len(msg), y=0, color = app.theme.style_header)

    elif app.debug and app.mode == "help":
        cprint("(press 'h' to exit)", justify = "right", color = app.theme.style_header, x = -23, y=0)
    elif app.mode == "help":
        cprint("(press any key to exit)", justify = "right", color = app.theme.style_header, x = -23, y=0)
    elif app.mode == "playlist":
        if not app.playlist:
            cprint("---", justify = "right", x=-15, y=0, color = app.theme.style_header)
        else:
            if app.show_page:
                try:
                    page = int(app.playlist_index/(screen.getmaxyx()[0]-4)) + 1 #added to remove page arg dependancy
                except ZeroDivisionError:
                    page = 0
                import math
                total = math.ceil(len(app.playlist)/(screen.getmaxyx()[0]-4))
                nav_status = f"PG {page}/{total}"
            else:
                nav_status = f"{app.playlist_index+1} of {len(app.playlist)}" #changed to fix bug
            cprint(nav_status, justify = "right", x=-16, y=0, color = app.theme.style_header)
    else:
        if app.show_page:
            try:
                page = int(app.index/(screen.getmaxyx()[0]-4)) + 1
            except ZeroDivisionError:
                page = 0

            total = ceil(len(app.all)/(screen.getmaxyx()[0]-4))
            nav_status = f"PG {page}/{total}"
        elif app.filter:
            index = app.index+1 if app.filtered else 0
            nav_status = f"{index} of {len(app.filtered)}"
        else:
            nav_status = f"{app.index} of {len(app.all)-1}"
        cprint(nav_status, justify = "right", x=-15, y=0, color = app.theme.style_header)

def draw_main():
    max_height, max_width = screen.getmaxyx()
    if app.mode == "filelist":
        app.index = chooser(app.all, app.index, height = max_height - 4)
    elif app.mode == "playlist":
        app.playlist_index = chooser(app.playlist, app.playlist_index, height = max_height - 4)
    else:
        if app.debug:
            draw_debug()
        else:
            draw_help()

def draw_footer():
    ptime = 0
    if true_savers_playing():
        style = COLOR.WHITE + curses.A_DIM
        clear_line(x=-14, y=-2)
        clear_line(x=0, y=-1)
        cprint(" ".rjust(screen.getmaxyx()[1]), fill = True, color = style)
    else:
        style = app.theme.style_header
    if player.filename or (app.sync and app.file):
        if app.is_streaming:
            ptime = time.perf_counter() - app.stream_start_time
        elif app.show_remaining:
            ptime = player.time_remaining
        else:
            ptime = player.time_pos
        if app.sync:
            status = "Synced"
            try:
                if app.file:
                    ptime = float(app.file.length)
                else:
                    ptime = 0
            except ValueError:
                ptime = 0
        elif player.pause:
            status = "Paused"
        else:
            status = "Playing"
        if app.stream_file:
            name = app.stream_file.title
        elif app.is_streaming:
            name = app.file.title
        elif app.sync:
            name = app.file.title
        else:
            name = player.filename
        if app.sync and not  app.show_sync_footer:
            cprint(" ", x=0, y=-1, fill = True, color = style)
        else:
            cprint(f"{status}: {name} ", x=0, y=-1, fill = True, color = style)

        if not true_savers_playing():
            if app.is_streaming:
                if not player.pause:
                    if app.screensaver_running:
                        app.stream_pos += .4
                    else:
                        app.stream_pos += .2
                if app.stream_pos > 100:
                    app.stream_pos = 0
                    draw_hline(x = 0, y = -2, style = app.theme.style_bars)
                draw_progress_bar(app.stream_pos, color = app.theme.style_bars)
            else:
                draw_progress_bar(player.percent_pos, color = app.theme.style_bars)

    elif app.midi_filename and app.midi_is_playing:
        cprint(f"Playing: {app.midi_filename} ", x=0, y=-1, fill = True, color = style)
        ptime = time.perf_counter() - app.midi_start_time
    else:
        cprint(" ", x=0, y=-1, fill=True, color = style)
    if not true_savers_playing() or ptime: #lose counter if no song playing during matrix
        if not app.sync or app.show_sync_footer:
            cprint(f" {format_time(ptime)}", x=-12, y=-1, justify = "right", color = style)
    screen.refresh()

def get_datetime(long_format = False):
    if not long_format:
        arg = time.strftime("%I:%M:%S %p")
    else:
        arg = "%A, %b %d | %I:%M:%S %p"
    return time.strftime(arg)

def draw_stat_bar():
    if not app.show_system_stats:
        return
    if not true_savers_playing():
        for n in (1,-2): #draw seperators
            draw_hline(x = 0, y = n, style = app.theme.style_bars)

    for lib in ("psutil", "shutil"):
        try:
            globals()[lib] = __import__(lib)
        except ModuleNotFoundError:
            app.send_msg(f"Error: {lib} not installed")
            app.show_system_stats = False
            return

    if app.stat_time():
        app.stat_time = Alarm(1)
        app.cpu = psutil.cpu_percent()
        app.ram = psutil.virtual_memory().percent
        app.drive = round((shutil.disk_usage("/")[2])/2**30, 2)
        height, width = screen.getmaxyx()
        if width >= 150:
            app.time = get_datetime(long_format = True)
        elif width >= 130 and not app.sync:
            app.time = get_datetime(long_format = True)
        else:
            app.time = get_datetime()
        top = ''
        topmem = ''
        while not top:
            try:
                processes = sorted(list(psutil.process_iter()), key=lambda item: item.cpu_percent(), reverse=True)
                top = processes[0].name()
                processes = sorted(list(psutil.process_iter()), key=lambda item: item.memory_percent(), reverse=True)
                topmem =processes[0].name()
            except psutil.NoSuchProcess:
                top = ''
                topmem = ''
        app.top = top
        app.topmem = topmem

    to_probe = len(app.filelist_to_probe) + len(app.playlist_to_probe) + len(app.visible_files_to_probe)
    tcolor = app.theme.style_header
    _, width = screen.getmaxyx()
    if width >= 26:
        cprint(f"CPU: {app.cpu}% ".ljust(11), x = 0, y = 0, color = tcolor, end = '')
    else:
        cprint(" ", x = 0, y = 0, color = tcolor, fill = True)
    if width >= 39:
        cprint(f"| RAM: {app.ram}% ".ljust(13), color = tcolor, end = '')
    if width >= 53:
        cprint(f"| HD: {app.drive}G ".ljust(15), color = tcolor, end = '')
    if width >= 67:
        if width >= 91:
            cprint(f"| Top: {app.top} ".ljust(19), color = tcolor, end = '')
            if not app.sync and to_probe: #app.settings["get_meta_with_ffprobe"]:
                cprint(f"| Probe: {to_probe} ", color = tcolor, fill = True)
            elif width > 122 and app.sync and true_savers_playing():
                cprint(f"| TopMem: {app.topmem} ".ljust(27), color = tcolor, end = '')
                cprint(f"| Particles: {len(Particle.data)} ", color = tcolor, fill = True)
            else:
                cprint(f"| TopMem: {app.topmem} ", color = tcolor, fill = True)
        elif to_probe and not app.sync:
            cprint(f"| Probe: {to_probe} ", color = tcolor, fill = True)
        else:
            cprint(f"| Top: {app.top} ".ljust(19), color = tcolor, fill = True)
    else:
        cprint(" ", color = tcolor, fill = True)
    cprint(f"  {app.time} ", x = -(len(app.time)+2), y = 0, color = app.theme.style_header)
    if app.msg:
        cprint(app.msg, x=0, y=0, justify = "right", color = app.theme.style_header)

def draw_progress():
    if app.sync and not app.show_sync_footer: return
    clear_line(x=-11, y=-1)
    ptime = 0

    if app.is_streaming:
        ptime = time.perf_counter() - app.stream_start_time

    elif player.filename:
        if app.show_remaining:
            ptime = player.time_remaining
        else:
            ptime = player.time_pos
    elif app.midi_filename and app.midi_is_playing:
        ptime = time.perf_counter() - app.midi_start_time

    if not matrix_playing() or ptime: #lose counter if no song playing during matrix
        cprint(f" {format_time(ptime)}", x=-12, y=-1, justify = "right", color = app.theme.style_header)
    if player.filename:
        if app.is_streaming:
            if not player.pause:
                if app.screensaver_running:
                    app.stream_pos += .4
                else:
                    app.stream_pos += .2

            if app.stream_pos > 100:
                app.stream_pos = 0
                draw_hline(x = 0, y = -2, style = app.theme.style_bars)

            draw_progress_bar(app.stream_pos, color = app.theme.style_bars)
        else:
            draw_progress_bar(player.percent_pos, color = app.theme.style_bars)

    if app.settings["dancing_errors"] and app.msg and "Error" in app.msg:
        msg = f"   {app.msg}"
        if random.randrange(0,4) == 1:
            msg = msg.upper()
        cprint(msg, x=-len(msg), y=0, color = app.theme.style_header)

##Other functions
def draw_help():
    help_strings = ("_↑ _↓ _k _j _P_g_U_p _P_g_D_o_w_n to navigate | _E_N_T_E_R to play/change dir",
        "_T_A_B to toggle Filelist/Playlist | _- _+ change vol",
        "_z or _p to pause/resume | _x stop | _< _> play prev/next",
        "Change theme: _`, _1 thru _8 | Override color: _(, _)",
        "sortby _name, _date, _size | _reverse sort| _count mode",
        "_S_P_A_C_E to _mark files | _inverse selection | _Unmark all",
        "_filter results | _Open file in external app",
        "_list mode |  _quit mplay | _Quit now",
        "",
        "Filelist Mode only:",
        "_goto directory | jump to _Home, _Music, _Playlist directories",
        "_B_A_C_K_S_P_A_C_E up one directory | _add current/marked to playlist",
        "",
        "Playlist Mode only:",
        "_Del from playlist | _{ or _} move entry up/down",
        " _Shuffle playlist | _Write playlist | _Erase playlist")
    footer = ("config & playlists saved to '~/.config/mplay'",
        "2025 by unpythonic-coder | MIT License | inspired by cplay",
        "(no warranty implied, use at your own risk)")

    cprint('', x=0, y=1)
    for i, text in enumerate(help_strings):
        y = i + 2
        cprint(' ', x=0, y=y, style = app.theme.style_main, fill = True)
        cprint(text, x=0, y=y, style = app.theme.style_main, color2 = app.theme.color_main, flag = '_', justify = "center")

    count = (screen.getmaxyx()[0]-4) - len(help_strings)
    if count > 0:
        for i in range(0, count):
            cprint(" ", color = app.theme.style_main, justify = "center")
    for i, text in enumerate(footer):
        cprint(text, color = app.theme.style_main, x=0, y=i-5, color2 = app.theme.color_main, flag = '_', justify = "center")

def cprint_fields(text):
    import re
    prev = None
    displaying_var = False
    for i, item in enumerate(re.split(r'(\s+)', text)):
        if prev and prev.endswith(':'):
            displaying_var = True
        elif not item.strip() and len(item) > 1:
            displaying_var = False
        elif item == "of":
            displaying_var = False
        if item in (True, "True"):
            color = COLOR.GREEN + curses.A_BOLD
        elif item in (False, "False", '0', 0, "None"):
            if prev and "index" in prev:
                color = COLOR.CYAN
            else:
                color = COLOR.RED
        elif type(item) is int or item.replace('.','').isdigit():
            color = COLOR.CYAN + curses.A_BOLD
        elif displaying_var:
            color = COLOR.YELLOW
        else:
            color = COLOR.WHITE
        cprint(item, color = color, end = '')
        if item.strip():
            prev = item
    cprint()

def draw_debug():
    height, width = screen.getmaxyx()
    if app.debug_output:
        move(0,2)
        for item in app.debug_output.split():
            cy, cx = screen.getyx()
            if len(item) + cx > width: cprint()
            cprint(f"{item} ", end = '', color = COLOR.WHITE)
        return

    cprint(f"{width} x {height}", justify = "right", x=0, y=2, color = COLOR.WHITE)
    cprint(f"player properties:", x=0, y=2, color = COLOR.WHITE)
    cprint_fields(f"  filename: {player.filename}")
    cprint_fields(f"  volume: {player.volume}          pause: {player.pause}")
    if app.is_streaming: cprint_fields(f"  app.is_streaming: True")
    cprint()

    cprint_fields("app.file properties:")
    try:
        if not player.filename or not app.file.name.lower() == player.filename.lower():
            cprint_fields(f"  name: {app.file.name}")
        cprint_fields(f"  title: {app.file.title}")
        cprint_fields(f"  path: {app.file.path}")
        if not app.file.path == app.file.fullpath:
            cprint_fields(f"  fullpath: {app.file.fullpath}")
        if app.file.totaltracks:
            cprint_fields(f"  track: {app.file.track} of {app.file.totaltracks}")
        else:
            cprint_fields(f"  track: {app.file.track}")

        if app.file.is_midi and app.file.midi_config:
            cprint_fields(f"  midi_config: {app.file.midi_config}")

        cprint_fields(f"  is_file: {app.file.is_file}     is_dir: {app.file.is_dir}     is_stream: {app.file.is_stream}")
        cprint_fields(f"  is_midi: {app.file.is_midi}     is_mod: {app.file.is_mod}     has comment: {bool(app.file.comment)}")
        cprint_fields(f"  Probed (by ffprobe): {app.file.probed}          duration: {app.file.duration}")

    except AttributeError:
        cprint_fields("  app.file: None")
    cprint_fields(f"  app.index: {app.index}")
    cprint()
    to_probe = len(app.filelist_to_probe) + len(app.playlist_to_probe) + len(app.visible_files_to_probe)
    cprint_fields("LENGTHS:")
    cprint_fields(f"  FileObj.data: {len(FileObj.data)}     app.all: {len(app.all)}     app.playlist: {len(app.playlist)}")
    cprint_fields(f"  app.filelist_to_probe: {len(app.filelist_to_probe)}     app.playlist_to_probe: {len(app.playlist_to_probe)}    app.visible_files_to_probe: {len(app.visible_files_to_probe)}")
    cprint()
    if app.playlist:
            if app.playlist_to_probe:
                status = "calculating"
            else:
                status = "approximate"
            cprint_fields(f"PLAYLIST:  {get_playlist_duration()} ({status})  {get_playlist_size()}")

    else:
        cprint_fields("PLAYLIST:")
    if app.playlist_name:
        cprint_fields(f"  app.playlist_name: {app.playlist_name}")
    cprint_fields(f"  app.playlist_index: {app.playlist_index} of {len(app.playlist)}")
    cprint_fields(f"  app.playlist_is_playing: {app.playlist_is_playing}     app.midi_is_playing: {app.midi_is_playing}")
    cprint_fields(f"  app.playlist_filter: {app.playlist_filter or 'None'}          app.filter: {app.filter or 'None'}")
    try:
        if app.playlist_is_playing:
            cprint_fields(f"  playlist_pos: {app.file.playlist_pos}")
    except AttributeError:
            pass

    cprint()
    cprint_fields("OTHER")
    if app.sync: label, value = "Sync", app.sync
    else: label, value = "Master", app.master
    cprint_fields(f"  {label}: {value}          Threads: {threading.active_count()}            app.list_view: {app.list_view}")
    if app.midi_is_playing and app.midi_config:
        cprint_fields(f"  app.midi_config: {app.midi_config}")
    cprint()
    pressed = key.pressed or key.last_pressed
    cprint(f"key.pressed: {pressed}", x=0, y=-3, justify = "right", color = COLOR.WHITE)
    cprint(f"key.raw: {key.raw}", x=0, y=-3, color = COLOR.WHITE)

def trap(func):
    """Prevents curses error messages, most of which are useless, and 
    caused by off-screen draw calls"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except curses.error:
            pass
    return wrapper

def bound(num, min_num, max_num): #Delete, not used
    return min(max(num, min_num), max_num)

def init_window(win = None, x = None, y = None, width = None, height = None, box = False):
    if not win: win = screen
    cy, cx = win.getyx()
    max_height, max_width = win.getmaxyx()
    if box and (width is not None and height is not None):
        if x is None: x = int(max_width/2 - width/2)
        if y is None: y = int(max_height/2 - height/2)
    x = cx if x is None else x
    y = cy if y is None else y
    if x < 0: x = max_width + x
    if y < 0: y = max_height + y
    width = max_width - x if not width else width
    height = max_height -y if not height else height
    return win, x, y, width, height, max_width, max_height

@trap
def cprint(text = '', x = None, y = None, *, flag = "",\
style = 0, color = 0, style2 = curses.A_REVERSE + curses.A_BOLD,\
color2 = 0, justify = None, fill = None, width = None, height = None,\
_border = 0, end = "\n", win = None, support_screensaver = False, ignore_char = None):
    win, x, y, width, height, max_width, max_height = init_window(win, x, y, width, height)
    if x < 0: x = max_width + x
    if y < 0: y = max_height + y
    move(x, y)
    original_style, original_color = style, color
    try: ##bugfix
        split_lines = "\\n" in text
    except TypeError:
        text = text.decode(errors="ignore") #new change to fix (rare) bug
        split_lines = "\\n" in text

    if split_lines:
        texts = text.split("\\n")
        for item in texts:
            cprint(item, x, y = None, flag = flag, style = style,\
            color = color, style2 = style2, justify = justify,\
            fill = fill, width = width, height = height,\
            _border = _border, end = "\n", win = win)
        return

    flag_count = text.count(flag) if flag else 0

    if justify == "center":
        text = text.center(width + flag_count - _border)
    elif justify == "right":
        text = text.rjust(width + flag_count - _border)
    elif fill and len(text):
        text = text.ljust(width + flag_count - _border, text[-1])

    if not any((flag, ignore_char, app.show_static, eink_playing(), modem_playing())):
        text = text[0:max_width-x]
        win.addstr(y, x, text, style + color)

    else:
        prev = ''
        n = 0
        for i, char in enumerate(text):
            if i >= width + flag_count: break
            if char == '\0':
                continue #trying to fix null character errors
            if ignore_char and char == ignore_char:
                n += 1
                continue
            if i > 0:
                prev = text[i-1]
            else:
                prev = None
            if all((prev, flag)) and prev == flag:
                win.addstr(y, x+n, char, style2 + color2)
            elif flag and char == flag:
                continue
            else:
                if support_screensaver and app.screensaver_running:
                    style = app.theme.style_main
                    char, style = run_screensaver(char, style, x=x, y=y, xn = x + n, yn = y + n)
                else:
                    style = original_style
                    if char == ' ' and app.show_static and (y > 0 and y < max_height - 1) and not random.randrange(0,200):
                        char = random.choice(('.', '`', "'"))
                win.addstr(y, x+n, char, style + color)
            if ord(char) > 10956 or unicodedata.east_asian_width(char) in ('W', 'F'): n += 1
            n += 1
    if end == "\n":
        move(0, y+1)

def get_wide_count(text):
    """Returns number of wide chars in string"""
    return sum(unicodedata.east_asian_width(char) in ("W", "F") for char in text)

def run_screensaver(char, style, x = None, y = None, xn = None, yn = None):
    curses.curs_set(False) #hide cursor
    if screensaver.engine == 1:
        return run_saver_eink(char, style)
    elif screensaver.engine == 2:
        return run_saver_slow_modem(char, style, x, y, xn, yn)
    else: 
        return char, style

def run_saver_eink(char, style):
    color = app.theme.color_main
    if color is None: color = COLOR.WHITE
    if not screensaver.data:
        screensaver.data = True
        screensaver.alarm = Alarm(.25)
        screensaver.upper = False
    B = curses.A_BOLD; N = curses.A_NORMAL; D = curses.A_DIM
    U = curses.A_UNDERLINE; u = curses.A_UNDERLINE + curses.A_DIM
    style = random.choice((B, N, N, D, D, D, D, D, U, U, U, u))
    if screensaver.particle_override and char == ' ' and not random.randrange(0,10):
        char = screensaver.particle_override
        char = char[:1]
    if char in (0, '0'): char = 'O'
    if screensaver.alarm():
        screensaver.upper = not screensaver.upper
        screensaver.alarm = Alarm(.25)
    if screensaver.upper:
        char = char.upper()
    else:
        char = char.lower()
        if str(char) == '0': char = 'o'
        elif str(char) == '9': char = 'g'
        elif str(char) == '5': char = 's'
        elif char == '?': char = "!"
        elif char == '-': char = '.'
    return char, style+color

def height_adjusted(num, min_size = 1):
    height, _ = screen.getmaxyx()
    return max(min_size, num * int(height/24))

def draw_saver_matrix():
    if not screensaver.data:
        if Particle.data:
            [p.delete() for p in Particle.data]
            Particle.data = []
        screensaver.data = True
    height, width = screen.getmaxyx()
    try:
        x = random.randrange(0,width-1)
    except ValueError:
        x = 0
    if x % 2 and random.randrange(0,20): x += 1
    clr = random.choice((COLOR.WHITE, COLOR.WHITE + curses.A_BOLD, COLOR.WHITE))
    char = screensaver.particle_override or app.kanji[random.randrange(0,len(app.kanji)-80)] ##KANJI

    dur = height_adjusted(random.choice((6,8,10,12,14)), min_size = 6)
    length = random.choice((5, 10, height, height, int(height*1.5),\
        int(height*1.5), int(height*1.5), height*2, height*2, height*2,\
        height*2))
    speed = random.choice((.6,.8,1,))
    speed = height_adjusted(speed, min_size = .3)
    speed = speed * screensaver.speed_mod
    if length < height: speed = 1
    ntimes = 1
    if width >= 80 and width < 100: ntimes = 2
    elif width >= 100 and width < 140: ntimes = 3
    elif width >= 140 and width < 180: ntimes = 4
    elif width >= 180 and width < 260: ntimes = 6
    elif width >= 260: ntimes = 8
    for i in range (0,ntimes):
        if random.choice((True, False)):
            Particle(char = char, x = x, ydir = speed, trail = True,\
            length = length, duration = dur, color = clr)
    [p.update() for p in Particle.data]
    if screensaver.stars and not random.randrange(0,200): draw_stars()

def draw_saver_tetragon():
    if not screensaver.data or not type(screensaver.data) is int:
        if Particle.data:
            for p in Particle.data:
                p.delete()
            Particle.data = []
        screensaver.init = True
        screensaver.flood = False
        if not app.has("saver_reset"): screensaver.reset = False
    if screensaver.init or screensaver.reset:
        screensaver.data = 7
        screensaver.theme_colors = get_theme_colors(singles_only = True)
        screensaver.theme_colors.append(COLOR.BLACK)
        screensaver.time = Alarm(random.choice((.5,1,1.5,2,2.5,3)))
        screensaver.init, screensaver.reset = False, False
        screensaver.fx = SimpleState("stars boxes clouds".split())
        screensaver.beam = 0

    height, width = screen.getmaxyx()
    char = screensaver.particle_override or chr(9617)
    if screensaver.laser: draw_laser()
    if screensaver.fx == screensaver.fx.stars: star = '.'
    elif screensaver.fx == screensaver.fx.boxes: star = '`'
    else: star = chr(9617)*10
    if screensaver.stars and len(Particle.data) < 1000: draw_stars(1, char=star)
    if screensaver.time():
        screensaver.time = Alarm(random.choice((.5,1,1.5,2,2.5,3)))
        if random.choice((True, False)):
            screensaver.data += 1
            if screensaver.data > 16: screensaver.data = 3
        else:
            screensaver.data = max(screensaver.data - 1, 3)
        if screensaver.flood and not random.randrange(0,10):
            if not screensaver.beam: screensaver.beam = 1
        elif screensaver.flood or not random.randrange(0,20):
            screensaver.flood = not screensaver.flood
            down = random.choice((True, False))
            dir = random.choice(("down", "other", "other"))
            if not screensaver.flood:
                screensaver.data = random.choice((3,7,7,7,15))
                if screensaver.fx == screensaver.fx.clouds:
                    screensaver.fx.randomize()
                else:
                    screensaver.fx.next()
            for p in Particle.data:
                if p.duration >= .05 and not screensaver.flood and not p.char in ('.'):
                    p.expired = Alarm(random.choice((2.7,3,3.3)))
                    if dir == "down":
                        p.ydir = random.choice((.5,.7,1,1.3))
                        p.gravity = .1
                    else:
                        p.xdir = random.choice((-3,-2.5,-2, 2,2.5,3))
                        p.ydir = random.choice((-1.5,-1.3,-1,1,1.3,1.5))

    n = 10 if screensaver.flood else 1
    if screensaver.data == 3: n = 3
    color = random.choice(screensaver.theme_colors + app.single_colors) + random.choice((curses.A_DIM, 0))
    for i in range(0,n):
        char = screensaver.particle_override or chr(random.choice((9608, 9617, 9617, 9617)))
        if not screensaver.flood:
            color = random.choice(screensaver.theme_colors)
        x = random.randrange(-10,width)
        y = random.randrange(-10,height)
        dur = random.choice((.1,.2,.3,.4))/5
        if screensaver.data == 3: dur = dur/1.5
        if screensaver.flood: dur *= 10
        dur = dur/abs(screensaver.speed_mod)
        if not screensaver.beam:
            Particle(char = char, x = x, y = y, xdir = 0, ydir = 0, color = color,\
                length = screensaver.data, duration = dur, no_draw = True)

    for p in Particle.data:
        if screensaver.beam > p.x:
            p.color = COLOR.BLACK
            p.delete()
        if p.char in ('`', '.', chr(9648)):
            if not random.randrange(0,20): #twinkle
                p.color = random.choice((COLOR.WHITE, COLOR.BLACK, COLOR.YELLOW, COLOR.RED))
        if p.char in ('.', chr(9648)):
            p.update()
            continue
        size = p.length
        for i in range(0, size):
            try:
                cprint(p.char, int(p.x + i), int(p.y), color = p.color)
                cprint(p.char, int(p.x + i), int(p.y + size), color = p.color)
                cprint(p.char, int(p.x), int(p.y + i), color = p.color)
                cprint(p.char, int(p.x + size), int(p.y + i), color = p.color)
                cprint(p.char, int(p.x + size), int(p.y + size), color = p.color)
            except (TypeError, OverflowError):
                p.delete()
        p.update()
    if screensaver.beam: draw_beam()

def draw_saver_plankton():
    ##--This code is a hot hacked mess
    ##--But likely can't rewrite without changing the feel
    ##--of half of mplay's included screensavers
    if not screensaver.data:
        if Particle.data:
            for p in Particle.data:
                p.delete()
            Particle.data = []
        screensaver.init = True
        screensaver.flood = False
        screensaver.shift = False
        if not app.has("saver_reset"): screensaver.reset = False

    if screensaver.init or screensaver.reset:
        screensaver.theme_colors = get_theme_colors(singles_only = True)
        screensaver.theme_colors.extend(screensaver.theme_colors)
        if screensaver.artists:
            screensaver.theme_colors.extend((COLOR.WHITE, COLOR.BLACK))
        else:
            screensaver.theme_colors.extend((COLOR.WHITE, COLOR.BLACK,\
                COLOR.BLACK, COLOR.YELLOW, COLOR.RED, COLOR.GREEN, COLOR.BLUE,\
                COLOR.CYAN, COLOR.MAGENTA, COLOR.BLACK))
        if screensaver.reset:
            screensaver.data = random.choice(screensaver.theme_colors)
        else:
            screensaver.data = COLOR.WHITE
        screensaver.time = Alarm(random.choice((.5,1,1.5,2)))
        screensaver.speed_adj = 1
        screensaver.x, screensaver.y = 0, 0
        screensaver.init = False

    height, width = screen.getmaxyx()
    dur = 16
    length = random.randrange(2,7)
    char = random.choice(("'",'"',".","*"))
    xspeed = random.randrange(2,14)/20
    xspeed *= max(.5, int(width/80)) #speed adj for wider screens
    xspeed *= screensaver.speed_mod
    yspeed = 0
    gravity = 0
    range_end = 2 #for use with screensaver.artists

    if screensaver.artists and not screensaver.pixels:
        xspeed = 0
        yspeed = random.choice((.08,.1,.1,.12,.14)) * screensaver.speed_mod
        gravity = .005
        if screensaver.speed_mod > 0:
            gravity *= screensaver.speed_mod/10
        char = "mplay"
        if app.file and is_file(app.file) and app.file.artist and not app.file.artist == "????" and not app.file.is_stream:
            char = app.file.artist[:18]
        elif app.file and app.file.title and app.file.is_stream:
            if '-' in app.file.title:
                char = app.file.title.split(' - ')[0].strip()[:18]
            else:
                char = app.file.title[:18]
        if width < 100: range_end = 20
        elif width < 80: range_end = 100
    elif screensaver.pixels:
        dur = 30
        xspeed = random.choice((.5,.7,1))* 2 * screensaver.speed_mod
        yspeed = 0
        #char = chr(9607) #--Should be safe to remove this line
        b, d = curses.A_BOLD, curses.A_DIM
        color_shift = {
            COLOR.MAGENTA: (COLOR.WHITE, d),
            COLOR.BLACK: (COLOR.WHITE, d),
            COLOR.CYAN: (COLOR.BLACK, d),
            COLOR.BLUE: (COLOR.CYAN, b),
            COLOR.YELLOW: (COLOR.WHITE, b),
            COLOR.GREEN: (COLOR.CYAN, d),
            COLOR.WHITE: (COLOR.MAGENTA, b),
            COLOR.RED: (COLOR.BLUE, d)}
    elif screensaver.rave:
        xspeed = 0
        yspeed = random.choice((.5,.7,.8,1,1))
        yspeed *= screensaver.speed_mod
    elif screensaver.speed_mod > 0 and screensaver.speed_mod < .25:
        yspeed = .25
    elif screensaver.speed_mod > -.25 and screensaver.speed_mod < 0:
        yspeed = -.20
    if screensaver.laser: draw_laser()

    if screensaver.time(): ## TIME 
        choices = [.5,1,1.5,2]
        if screensaver.pixels: choices.extend((4,5))
        stime = random.choice(choices)
        if screensaver.artists: stime = stime/2
        screensaver.time = Alarm(stime)
        if screensaver.stars: draw_stars()

        if random.choice((True, False, False, False)):
            screensaver.data = random.choice(screensaver.theme_colors)
        screensaver.speed_adj = random.choice((.5,.75,1,1,1,1,1,1,2,2))
        if screensaver.pixels:
            screensaver.speed_adj = 1
            if screensaver.data in (COLOR.BLACK, COLOR.WHITE):
                screensaver.shift = not screensaver.shift
            else:
                screensaver.shift = random.choice((True, False, False,False))
        elif not screensaver.artists:
            if screensaver.data in (COLOR.BLACK, COLOR.WHITE):
                screensaver.shift = not random.randrange(0,10)

        if not random.randrange(0,100):
            plankton_transition()

        screensaver.x, screensaver.y = 0, 0
        if screensaver.pixels and random.randrange(1,10) == 1 and len(Particle.data) < 700:
            screensaver.flood = True
        elif not screensaver.artists and not screensaver.pixels and random.randrange(1,10) == 1 and xspeed >= .4:
            screensaver.flood = True
        elif screensaver.artists and not random.randrange(0,range_end) and stime > .5 and len(Particle.data) < 400\
        and not screensaver.data in (COLOR.BLACK, COLOR.WHITE):
            screensaver.flood = True
        else:
            screensaver.flood = False

        if not screensaver.speed_adj == 1:
            for p in Particle.data:
                p.xdir = min(20, p.xdir * screensaver.speed_adj)
                if yspeed and p.xdir > p.ydir*2: ##new, may not be doing much
                    p.xdir = 0
    if screensaver.flood:
        if screensaver.artists or (screensaver.pixels and random.choice((True, False, False))):
            flood_particles_plankton()
    if screensaver.x < width:
        screensaver.x += 3
    if screensaver.y < height:
        screensaver.y += 1

    n = max(1, int(width/80))
    if screensaver.flood and not screensaver.artists: n *= 3
    try:
        px = min(20, random.randrange(0, int(width/8))) #for use with saver_pixels
    except ValueError:
        px = 0

    for i in range(0,n): ##Create Particles
        if screensaver.artists and random.choice((True, False)):
            continue

        if screensaver.pixels and not random.randrange(0,500):
            xspeed = xspeed/2
            yspeed = random.choice((.25, .30, .35, .40, .45))
            dur = random.choice((7,14,21))
            x = px

        if screensaver.rave:
            div = 1 
        else:
            div = 3 #used below, to limit p creation to left of screen
        if xspeed < .25:
            try:
                x = random.randrange(0,int(width/div))
            except ValueError:
                x = 0
            clr = screensaver.data + curses.A_DIM
        elif xspeed == .25:
            x = 0
            clr = screensaver.data + random.choice((curses.A_DIM, 0))
        else:
            x = 0
            clr = screensaver.data
        try:
            y = random.randrange(0,height-1) #I like it better here
        except ValueError:
            y = 0
        if screensaver.pixels:
            y = random.randrange(1,6)
        elif screensaver.rave:
            y = 0
        elif (screensaver.speed_mod > 0 and screensaver.speed_mod < .25) or screensaver.artists:
            x = random.randrange(0,width)
            y = 0
        elif screensaver.speed_mod > -.25 and screensaver.speed_mod < 0:
            x = random.randrange(0,width)
            y = height

        if random.choice((True, False)):
            clr = COLOR.BLACK + curses.A_BOLD
            xspeed *= .75

        Particle(char = char, x = x, y = y, xdir = xspeed, ydir = yspeed,\
        trail = False, length = length, duration = dur, color = clr, gravity = gravity)

    for p in Particle.data: ##Update particles
        style = random.choice((curses.A_DIM, 0, 0, curses.A_BOLD))
        if screensaver.shift and not all((screensaver.artists, screensaver.pixels))\
        and not random.randrange(0,10):
            if p.color in (COLOR.BLACK, COLOR.BLACK + curses.A_DIM):
                p.color = COLOR.WHITE + curses.A_DIM
            elif p.color in (COLOR.WHITE, COLOR.WHITE + curses.A_DIM):
                p.color = COLOR.BLACK

        if screensaver.reset and not screensaver.artists and not screensaver.pixels:
            p.color = screensaver.data + style
            p.xdir = random.choice((.5,.7,1))
        if screensaver.data == COLOR.BLACK:
            if random.randrange(1,20) == 1:
                p.color = screensaver.data + style

        if p.color == COLOR.BLACK and screensaver.artists and not random.randrange(0,10):
                p.color = COLOR.WHITE + curses.A_DIM
        elif p.color == COLOR.WHITE and screensaver.artists and not random.randrange(0,10):
                p.color = COLOR.RED
        elif screensaver.pixels and screensaver.shift and not random.randrange(0,10):
            if p.color in color_shift.keys():
                c, s = color_shift[p.color]
                p.color = c + s

        elif p.x <= screensaver.x and p.y <= screensaver.y\
        and random.choice((True, False, False)):
            if p.color in (COLOR.BLACK, COLOR.BLACK+curses.A_DIM, \
            COLOR.BLACK+curses.A_BOLD):
                if random.randrange(1,20) == 1:
                    p.color = screensaver.data + curses.A_DIM
            else:
                p.color = screensaver.data + style
        if screensaver.artists or screensaver.stars:
            if p.x > width:
                p.x = 0
            if p.char == '-' and p.xdir < .25:
                p.char = '.'
            elif p.char == '.' and not random.randrange(0,20):
                if p.x % 3 and p.y % 3:
                    p.color = random.choice((COLOR.WHITE, COLOR.BLACK, COLOR.YELLOW))
            if screensaver.stars and p.xdir >= 1 and char in ("'",'"',".","*"):
                p.char = '_'
            elif screensaver.stars and p.xdir < 1 and char == '_':
                p.char = '.'

        elif screensaver.pixels:
            if p.x > width:
                p.x = width
                p.y = p.y - 6
                p.xdir *= -1
            if p.x < 0:
                p.x = 0
                p.y = (height-p.y)-1
                p.xdir *= -1

        elif p.xdir >= 1:
            p.char = "_"
        elif p.char == "_":
            p.char = "."
        elif p.xdir <= .3:
            p.char = random.choice(("'",'"',".","*"))
        p.update()
    screensaver.reset = False

def draw_laser(vertical = True):
    height, width = screen.getmaxyx()
    if vertical:
        rx = random.randrange(0, width)
        ry = 0
    else:
        rx = 0
        ry = random.randrange(0, height)
    try:
        rc = random.choice(screensaver.theme_colors)
    except AttributeError:
        screensaver.theme_colors = get_theme_colors(singles_only = True)
        rc = random.choice(screensaver.theme_colors)
    rs = random.choice((0, 0, 0, curses.A_BOLD, curses.A_DIM))
    if vertical:
        draw_vline(rx, 0, style = rs, color = rc)
    else:
        draw_hline(0, ry, style = rs, color = rc)

def draw_beam():
    """Rare beam that goes across Tetragon screen and wipes away particles"""
    try:
        x = screensaver.beam
    except AttributeError:
        x = screensaver.beam = 0
    if not x: return
    _, width = screen.getmaxyx()
    try:
        rc = random.choice(screensaver.theme_colors)
    except AttributeError:
        screensaver.theme_colors = get_theme_colors(singles_only = True)
        rc = random.choice(screensaver.theme_colors)
    rs = random.choice((0, 0, 0, curses.A_BOLD, curses.A_DIM))
    draw_vline(x, 0, style = rs, color = rc)
    x = x + 2 if x < width else 0
    screensaver.beam = x

def flood_particles_matrix():
    """Press SPACE to flood matrix paricles (sync mode only)"""
    height, width = screen.getmaxyx()
    for i in range(5):
        x = random.randrange(0,width-1)
        if x % 2 and random.randrange(0,20): x += 1
        dur = random.randrange(5,80)/10
        length = random.randrange(5,43)
        if height >= 35:
            dur = int(dur * 1.8)
            length = int(length * 1.6)
        clr = random.choice((COLOR.WHITE, COLOR.WHITE + curses.A_BOLD, COLOR.WHITE))
        char = app.kanji[random.randrange(0,len(app.kanji)-80)] ##KANJI
        speed = random.randrange(2,10)/10
        Particle(char = char, x = x, ydir = speed, trail = True, length = length, duration = dur, color = clr)

def flood_particles_plankton():
    height, width = screen.getmaxyx()
    char = '|'
    if screensaver.rave:
        yspeed = random.choice((.8,1,1.2))
    elif screensaver.speed_mod > 0 and screensaver.speed_mod < .25:
        yspeed = .25*1.5
    elif screensaver.speed_mod > -.25 and screensaver.speed_mod < 0:
        yspeed = -.20*1.5
    else:
        yspeed = 0
        char = '-'
    if screensaver.particle_override and not screensaver.stars:
        char = screensaver.particle_override
    if screensaver.pixels:
        n = 3
    else:
        n = 5
    dur = random.choice((9, 9.5, 10, 10.5, 11))
    if screensaver.artists: dur = random.choice((19, 19.5, 20, 20.5, 21))
    for i in range(n):
        if char== '-' or screensaver.pixels:
            xspeed = random.randrange(2,10)/3
            if screensaver.artists: xspeed = max(2, xspeed)
            if screensaver.pixels: xspeed = xspeed/2
            try:
                y = random.randrange(1,height-1)
            except ValueError:
                y = 0
            x = 0
        else:
            xspeed = 0
            try:
                x = random.randrange(0,width-1)
            except ValueError:
                x = 0
            if screensaver.speed_mod > 0:
                y = 0
            else:
                y = height - 1
        clr = random.choice(screensaver.theme_colors)
        if screensaver.pixels:
            clr = COLOR.BLACK
        Particle(char = char, x = x, y = y, xdir = xspeed, ydir = yspeed, trail = False, duration = 10, color = clr)
    screensaver.speed_adj = 2

def draw_stars(n = 15, char = '.'):
    wandering = screensaver.wandering
    height, width = screen.getmaxyx()
    for i in range(n):
        x = random.randrange(0,width)
        y = random.randrange(0,height)
        if wandering:
            xdir = random.choice((-.02,-.017,-.015,-.01,.01,.015,.017,.02)) * 40
            ydir = random.choice((-.02,-.017,-.015,-.01,.01,.015,.017,.02)) * 20
            if screensaver.speed_mod < 0:
                xdir *= screensaver.speed_mod
                ydir *= screensaver.speed_mod/2

        else:
            xdir = 0
            ydir = 0

        dur = random.choice((19,19.5,20,20.5,21))
        try:
            color = random.choice(screensaver.theme_colors)
        except AttributeError:
            screensaver.theme_colors = get_theme_colors(singles_only = True)
            color = random.choice(screensaver.theme_colors)
        if wandering:
            color += random.choice((0, 0, 0,curses.A_DIM, curses.A_DIM, curses.A_BOLD))
        Particle(char = char, x = x, y = y, xdir = xdir, ydir = ydir, duration = dur, color = color)

def draw_saver_khaos():
    if not screensaver.data:
        if Particle.data:
            for p in Particle.data:
                p.delete()
            Particle.data = []
        screensaver.data = True
        screensaver.alarm = Alarm(2)
        app.spawn_time = Alarm(.001)
        screensaver.color = COLOR.BLACK
        screensaver.reverse = False
        screensaver.shrink = False
        screensaver.theme_colors = get_theme_colors(singles_only = True)
        screensaver.theme_colors.append(app.theme.color_main)
        screensaver.choices = (".", "`", "'")
        screensaver.clear_time = Alarm(1)
    height, width = screen.getmaxyx()
    xcenter = int(width/2)
    ycenter = int(height/2)
    if screensaver.clear_time():
        screensaver.clear_time = Alarm(1)
        screen.clear()
    if screensaver.alarm():
        screensaver.alarm = Alarm(random.choice((1,1.5,2,2.5,3,4,6)))
        if screensaver.stars: draw_stars()

        if random.choice((True, True, True, False)): #theme color affects khaos, synced or not
            screensaver.color = random.choice(screensaver.theme_colors)
            if screensaver.color == COLOR.WHITE:
                    screensaver.color == app.theme.color_screensaver
        else:
            screensaver.color = random.choice((COLOR.RED, COLOR.GREEN, COLOR.YELLOW, COLOR.MAGENTA, COLOR.BLUE, COLOR.CYAN, COLOR.BLACK))
        if screensaver.shrink:
            screensaver.shrink = False
        elif random.randrange(1,7) == 1:
            screensaver.shrink = True
            if random.randrange(1,4) == 1:
                screensaver.choices = (".", "`", "'", "|")
                screensaver.alarm = Alarm(random.choice((4,6,8,10,16)))
            else:
                screensaver.choices = (".", "`", "'")

    if random.randrange(1,50) == 1: #originally 100
        if screensaver.reverse:
            screensaver.reverse = False
        else:
            screensaver.reverse = random.choice((True, False))
        if random.randrange(8) == 1:
            app.spawn_time = Alarm(random.choice((2,4,8)))
            if random.choice((True, False)):
                for p in Particle.data:
                    if int(p.ydir) == 0:
                        p.ydir = random.choice((-1, 1))

    if width > 80:
        spawn_count = range(random.choice((1,3,5,10,20,30)))
    else:
        spawn_count = range(random.choice((1,1,2,3,5,10)))

    for i in spawn_count:
        spawner = random.choice(("top", "bottom", "left", "right"))
        if spawner == "top":
            x = random.randrange(0, width)
            y = 0
            xdir = (xcenter - x)/20
            ydir = 1
        elif spawner == "bottom":
            x = random.randrange(0, width)
            y = height - 1
            xdir = (xcenter - x)/20
            ydir = -1
        elif spawner == "left":
            x = 0
            y = random.randrange(0, height)
            xdir = 1
            ydir = (ycenter - y)/10
        elif spawner == "right":
            x = width - 1
            y = random.randrange(0, height)
            xdir = -1
            ydir = (ycenter - y)/10

        xdir = xdir/2 * min(width/80, 1.5)
        ydir = ydir/2 * min(height/24, 1.3)
        xdir = xdir * screensaver.speed_mod
        ydir = ydir * screensaver.speed_mod

        if screensaver.shrink:
            char = random.choice(screensaver.choices)
        else:
            char = random.choice(app.kanji)
        clr = screensaver.color
        color = random.choice((clr + curses.A_DIM, clr + curses.A_NORMAL, clr + curses.A_BOLD, COLOR.WHITE + curses.A_DIM, COLOR.BLACK, COLOR.BLACK + curses.A_BOLD))
        if screensaver.reverse:
            color += curses.A_REVERSE
        duration = random.randrange(3,10)
        length = random.randrange(3,20)
        if app.spawn_time():
            Particle(char = char, x = x, y = y, xdir = xdir, ydir = ydir, trail = True, length = length, duration = duration, color = color)
    for p in Particle.data:
        if random.randrange(1,5) == 1:
            p.color = color
        if p.x < xcenter:
            p.x += .4
        elif p.x > xcenter:
            p.x -= .4
        if p.y < ycenter:
            p.y += .1
        elif p.y > ycenter:
            p.y -= .1
        p.update()

def shrink_particles():
    """Press SPACE to shrink khaos particles (sync mode only)"""
    for p in Particle.data:
        char = random.choice((".", "`", "'", "|"))
        if screensaver.particle_override or screensaver.bounce: char = chr(9603)
        if random.randrange(1,7) == 1 or screensaver.particle_override:
            p.char = char

def burst_of_color():
    """Press 'c' for a burst of khaos color (sync mode only)"""
    if random.choice((True, False)):
        screensaver.color = random.choice(screensaver.theme_colors)
    else:
        screensaver.color = random.choice((COLOR.RED, COLOR.GREEN, COLOR.YELLOW, COLOR.MAGENTA, COLOR.BLUE, COLOR.CYAN, COLOR.BLACK))
    for p in Particle.data:
        if random.choice((True, False, False)):
            p.color = screensaver.color

def khaos_transition():
    reverse = random.choice((True, False))
    shrink = random.choice((True, False, False, False))
    if shrink:
        screensaver.alarm = Alarm(random.choice((3,4,5,6)))
        screensaver.shrink = shrink

    for p in Particle.data:
        if reverse:
            p.ydir = -p.ydir * 2
            p.xdir = -p.xdir * 4    
        else:
            p.ydir = 2
    if reverse:
        app.spawn_time = Alarm(1.5)
    else:
        app.spawn_time = Alarm(1)

def matrix_transition():
    for p in Particle.data:
        p.ydir = min(10, p.ydir * random.choice((1.5,2,2.5,3)))

def plankton_transition(): ##cyber_plankton_transition()
    for p in Particle.data:
        if screensaver.pixels and random.choice((True, False)):
            height, width = screen.getmaxyx()
            if p.y < height/2:
                p.ydir = random.choice((.5,.7,1))
            else:
                p.ydir = random.choice((-.5, -.7, -1))
            p.expired = Alarm(random.choice((3.5,3.7,4,4.2,4.5,4.7,5,5.5,6,7,9,9.5,10)))
        else:
            if p.xdir:
                p.xdir = min(9, p.xdir * random.choice((1.5,2,2.5,3,3.5,4)))
            if p.ydir:
                p.ydir = min(3, p.ydir * random.choice((1.3,1.5,1.7,2,2)))

def tetragon_transition():
    for n in range(0,10):
        draw_stars(char = chr(9648))
    for p in Particle.data:
        p.ydir = min(10, p.ydir * random.choice((1.5,2,2.5,3)))

def draw_saver_slow_modem():
    meta_x = 2
    spacer = 3
    style = app.theme.style_main
    height, width = screen.getmaxyx()
    for y in range(2, height-2):
        line = ' ' * width
        cprint(line, 0, y, style = style, support_screensaver = True)
        cprint('  ', 0, y, style = app.theme.style_icons)
    if app.file and type(app.file) is not str and not app.file.is_dir:
        ## Added to probe mod files during screensaver
        if app.settings["get_meta_with_ffprobe"] and app.file.is_mod and not app.file.probed and not app.sync:
            app.visible_files_to_probe.append(app.file)
            time.sleep(.33) #was .5
        elif app.settings["get_meta_with_ffprobe"] and not app.file.probed\
        and not app.file.is_midi and not app.file.is_stream and not app.file.ext == "m3u"\
        and not all((app.file.duration, app.file.album)):
            app.visible_files_to_probe.append(app.file)
            time.sleep(.33) #was .5

        x = meta_x
        if app.file.is_stream:
            fileinfo = ("title", "station", "website", "url", "genre", "rate")
        elif not app.file.is_midi and (app.music_tag or app.settings["get_meta_with_ffprobe"]):
            fileinfo = ("title", "artist", "album", "track", "genre", "duration", "year", "rate")
        else:
            fileinfo = ("name", "path", "date", "size", "ext", "midi_config")
        for i, item in enumerate(fileinfo):
            if item == "rate" and app.file.is_mod:
                item = "size"
            attr = getattr(app.file, item)
            if item == "track":
                attr2 = getattr(app.file,"totaltracks")
                if attr2 and attr2 != '0' and '/' not in str(attr) and "on" not in str(attr):
                    attr = f"{attr} of {attr2}"
            elif item == "name":
                attr = Path(attr).stem.replace("_", " ").title()
            elif item == "path":
                item = "Folder"
                attr = f"{Path(attr).parent.stem}{Path(attr).parent.suffix}"

            elif item == "size":
                size = round(attr/(1024*1024),2)
                if size >= 1:
                    attr = f"{round(attr/(1024*1024)):.2f} MB"
                else:
                    attr = f"{round(attr/(1024)):.2f} kb"
            elif item == "date":
                item = "Mod Date"
                attr = str(datetime.datetime.fromtimestamp(attr)).split('.')[0]
            elif item == "midi_config":
                item = "Config"
                if not attr: attr = app.midi_config or "Default"
                if attr: attr = Path(attr).stem
            elif item == "duration":
                item = "time"
                if attr and attr.replace('.', '', 1).isdigit():
                    attr = format_time(float(attr))
            elif item == "url":
                item = "stream"
            if not app.file.is_midi and item == "Config":
                pass
            else:
                cprint(f"{item.title()}: {attr}", meta_x, 2+i, style = style, support_screensaver = True)

        if app.file.comment:
            cprint("-----", meta_x, 10, style = style, support_screensaver = True)
            y = 11
            comments = [item.rstrip() for item in app.file.comment.replace('\r', '\n').split("\n")]
            clean_comments = []
            prev = None
            for i, line in enumerate(comments):
                if i > 0:
                    prev = comments[i-1]
                if prev is not None and not line.strip() and not prev.strip():
                    continue
                clean_comments.append(line.strip().replace('\0', ''))
            col_width = len(max(clean_comments, key = len))
            col_width = max(col_width, 16)
            app.column_width = col_width + spacer
            try:
                if not screensaver.comments:
                    raise AttributeError
                clean_comments = screensaver.comments
            except AttributeError:
                screensaver.comments = clean_comments
            for i, line in enumerate(clean_comments):
                if y >= height - 2:
                    if x == meta_x:
                        y = 5
                    else:
                        y = 2
                    x += col_width + spacer
                if x + col_width < width or col_width >= width:
                    cprint(line, x, y, style = style, support_screensaver = True)
                elif x + col_width >= width:
                    screensaver.comments_fit = False
                if clean_comments:
                    if i > height - 13 or len(comments) > height-13:
                        for i in range(col_width+spacer+1, width, col_width+spacer):
                            vy = 2
                            if i == col_width+spacer+1: vy = 5
                            if i + col_width < width:
                                draw_vline(x = i, y = vy, style = style)
                y += 1
        elif app.file.is_mod and not app.file.probed:
            cprint("(not probed)", 2, -3, style = style)
    else:
        binary = ''
        for i in range(0,  height):
            binary = "".join([random.choice(('0','1')) for _ in range(0,width)])
            cprint(binary, 2, 2+i, style = style, support_screensaver = True)
        cprint("No file in memory ", 0, 0, fill = True, style = app.theme.style_header)

def run_saver_slow_modem(char, style, x, y, xn, yn):
    ##New slow modem code
    height, width = screen.getmaxyx()
    def reset_data():
        for nx in range(0, width):
            for ny in range(0, height):
                if ny < 2:
                    screensaver.data[(nx, ny)] = True
                else:
                    screensaver.data[(nx, ny)] = False
    if not screensaver.data:
        screensaver.data = []
        screensaver.alarm = Alarm(.025)
        screensaver.data = {}
        screensaver.pos = (0,2)
        screensaver.pass_made = False
        screensaver.comments = None
        screensaver.comments_fit = True
        reset_data()
    if screensaver.pass_made:
        try:
            col_width = app.column_width
        except AttributeError:
            col_width = width
    else:
        col_width = width
    if screensaver.alarm() and screensaver.pos is not None:
        alarm_time = 80*.018/width
        if screensaver.speed_mod > 0:
            mod = 1/screensaver.speed_mod
            alarm_time *= mod

        if screensaver.pass_made:
            alarm_time = alarm_time*3

        screensaver.alarm = Alarm(alarm_time)
        px, py = screensaver.pos
        screensaver.data[(px,py)] = True

        px += 1
        if px > col_width:
            px = 0
            py += 1
            if screensaver.comments and len(screensaver.comments) == 1\
            and screensaver.pass_made and is_file(app.file) and app.file.comment\
            and not screensaver.comments_fit:
                screensaver.comments.pop(0)
                screensaver.pass_made = False
                px, py = 0, 2
                reset_data()
            elif screensaver.comments and screensaver.pass_made\
            and not screensaver.comments_fit:
                screensaver.comments.pop(0)

            ht = height + 2 if not screensaver.pass_made and screensaver.comments else min(height - 2, 11)
            if py >= ht:
                px, py = 0, 2
                if not screensaver.comments and height > 12:
                    py = height-3
                    for i in range(0,width):
                        screensaver.data[(i, py)] = False
                elif not screensaver.pass_made:
                    screensaver.pass_made = True

        if screensaver.pos:
            screensaver.pos = (px, py)
    try:
        if screensaver.data[(xn, y)]:
            if not screensaver.pass_made and screensaver.pos and screensaver.pos[1] == y:
                style = app.theme.style_selected
                if char == ' ':
                    char = random.choice((' ', ' ', ' ', '|'))
                    if screensaver.particle_override and char == '|': char = screensaver.particle_override[:1]
            elif screensaver.pass_made and screensaver.pos and screensaver.pos[0] == xn and screensaver.pos[1] == y:
                style = app.theme.style_selected
            elif screensaver.pass_made and screensaver.pos and screensaver.pos[0] == xn+1 and screensaver.pos[1] == y:
                style = COLOR.BLACK_ON_WHITE + curses.A_BOLD + curses.A_REVERSE
            elif screensaver.pass_made and screensaver.pos and screensaver.pos[0] == xn+2 and screensaver.pos[1] == y:
                style = COLOR.BLACK_ON_WHITE + curses.A_NORMAL + curses.A_REVERSE
            elif screensaver.pass_made and screensaver.pos and screensaver.pos[0] == xn+3 and screensaver.pos[1] == y:
                style = COLOR.BLACK_ON_WHITE + curses.A_DIM + curses.A_REVERSE

            elif char == ' ' and random.randrange(1,50) == 1:
                char = random.choice(('.', '`',))
                if app.theme.color_main != app.theme.style_main - (curses.A_REVERSE + curses.A_DIM):
                    style = app.theme.color_main + random.choice((curses.A_DIM, curses.A_DIM,\
                    curses.A_NORMAL, curses.A_BOLD))
        else:
            char = ' '
            if random.randrange(1,200) == 1:
                char = random.choice(('.', '`'))
    except KeyError:
        char = ' '
    return char, style

@trap
def draw_hline(x = None, y = None, width = None, style = 0, color = 0, chara = '', win = None):
    if not chara:
        chara = curses.ACS_HLINE
    elif len(chara) > 1:
        chara = chara[0]
    win, x, y, width, height, _, _ = init_window(win, x, y, width)
    win.hline(y, x, chara, width, style + color)

@trap
def draw_vline(x = None, y = None, height = None, style = 0, color = 0, chara = '', win = None):
    if not chara:
        chara = curses.ACS_VLINE
    elif len(chara) > 1: chara = chara[0]
    win, x, y, width, height, _, _ = init_window(win, x, y, height = height)
    win.vline(y, x, chara, height, style + color)

@trap
def confirmation(message = "Quit? (y/n)", x = 0, y = -1, style = curses.A_NORMAL, width = None, height = 1, anyKey = False, win = None):
    win, x, y, _, height, max_width, max_height = init_window(win, x, y, width, height, box = True)
    if not width: width = max_width# - 12
    newwin = curses.newwin(height+1, width+1, y, x)
    style = get_standout()
    while(True):
        cprint(f" ", style = style, fill = True, win = newwin, end = None)
        cprint(f"{message} ", x = 0, y=0, style = style, fill = False, win = newwin)
        newwin.refresh()
        key = newwin.getkey()
        if key:
            #if not anyKey and key not in 'YyNn': continue ##should this be switched back on!?
            newwin.clear()
            cprint(f" ", style = app.theme.style_header, fill = True, win = newwin, end = None)
            newwin.refresh()
            del newwin
            if key in 'Yy': return True
            return False

@trap
def get_choice(message = "Enter text", x = 0, y = -1, width = None, height = 1, win = None, style = 0, color = 0):
    win, x, y, _, height, max_width, max_height = init_window(win, x, y, width, height, box = True)
    if not width: width = max_width - 12
    newwin = curses.newwin(height+1, width+1, y, x)
    while(True):
        cprint(f"{message} ", style = style, color = color, fill = True, win = newwin)
        newwin.refresh()
        key = newwin.getkey()
        if key:
            newwin.clear()
            del newwin
            return key

@trap
def get_text(message = "Filter: ", x = 0, y = -1, width = None, height = 1,
    default_text = '', anyKey = False, win = None, allow_spaces = False, numbers_only = False,
    additional_chars = '', replace = None, command_entry = False):
    win, x, y, _, height, max_width, max_height = init_window(win, x, y, width, height, box = True)
    if not width: width = max_width # - 12

    newwin = curses.newwin(height+1, width+1, y, x)
    newwin.keypad(True)
    curses.curs_set(True) #show cursor
    offset = 0
    index = 0
    if numbers_only:
        acceptable_chars = "0123456789"
    else:
        acceptable_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-.#_" + additional_chars
    k = Key()
    text = str(default_text)
    style = get_standout() # Style here includes color

    while(True):
        cprint(f"{message}{text} ", fill = True, style = style, win = newwin)
        move(len(message)+len(text)-offset, 0, win = newwin)
        newwin.refresh()
        #if offset:
        part1, part2 = text[0:len(text)-offset], text[len(text)-offset:]
        #else:
        #part1, part2 = text, ''
        k.detect(win = newwin)
        if k.raw is None: continue
        if k("ESC") or k.raw == 5:
            text = None
            break
        elif k("UP") and command_entry:
            index -= 1
            offset = 0
            try:
                text = app.command_history[index]
            except IndexError:
                index = len(app.command_history) - 1
                text = app.command_history[index]
            part1, part2 = text, ''
        elif k("UP"):
            text = None
            break
        elif k("DOWN") and command_entry:
            index += 1
            offset = 0
            try:
                text = app.command_history[index]
            except IndexError:
                index = 0
                text = app.command_history[index]
            part1, part2 = text, ''

        elif k("LEFT"):
            offset = min(len(text), offset+1)
        elif k("RIGHT"):
            offset = max(0, offset-1)
        elif k("ENTER"):
            break
        elif k("BACKSPACE") and len(text):
            text = f"{part1[:-1]}{part2}"
        elif allow_spaces and k("SPACE") and len(text) < width - len(message):
            if command_entry and '=' not in text:
                text = f"{part1}={part2}"
            elif command_entry:
                text = f"{part1}_{part2}"
            else:
                text = f"{part1} {part2}"
        elif k.pressed in acceptable_chars and len(text) < width - len(message):
            text = f"{part1}{k.pressed}{part2}"
        newwin.clear()

        if replace and type(replace) is dict:
            for key, value in replace.items():
                text = text.replace(key, value)

    del newwin
    curses.curs_set(False) #hide cursor
    app.updated = True
    return text

def chooser(array, index = 0, height = 10):
    max_height, max_width = screen.getmaxyx()
    if index < 0: index = len(array) - 1
    if index >= len(array): index = 0
    try:
        page = int(index/height)
        if not app.lastpage == page:
            screen.clear()
            app.lastpage = page
    except ZeroDivisionError: #stop drawing if screen too small
        return index
    total = 1
    for n in range(0, max_height - 4): ##background fill
        cprint(" ", x = 0, y = 2+n, fill = True, style = app.theme.style_main, support_screensaver = True)
        cprint("  ", x = 0, y = 2+n, style = app.theme.style_icons) ##new bit to fill icon column
    move(0,2)
    pos = page*(height)

    pageflip = app.settings["pageflip"]
    if pageflip:
        app.chooser_range = range(pos, pos + height)
    elif app.chooser_range is None:
        app.chooser_range = range(index, index + height)
    elif  index not in app.chooser_range and index < height and app.moving_down:
        app.chooser_range = range(0, height)

    else:
        if index not in app.chooser_range:
            if app.moving_down:
                app.chooser_range = range(index - height + 1, index + 1)
            else:
                app.chooser_range = range(index, index + height)

    for i in app.chooser_range:
        try:
            item = array[i]
        except IndexError:
            break
        isfile, isdir = False, False
        show_meta = False
        if pageflip and (total > height or i < int(page*height)):
            continue

        if type(item) is str:
            name = item.strip()
        elif item.is_dir:
            name = item.name + '/'
            isdir = True
        else:
            name = item.name
            isfile = True
        tag1 = tag2 = ' '

        #if app.settings["get_meta_with_ffprobe"] and app.list_view in ("metadata", "custom1", "custom2"):
        if app.settings["get_meta_with_ffprobe"] and (app.list_view == "metadata" or str(app.list_view).startswith("custom")):

            if isfile and not item.is_midi and not item.is_stream and not item.probed\
            and not item.ext == "m3u" and (item.duration == "----" or not item.duration):
                app.visible_files_to_probe.append(item)
                app.is_probing = True
            elif isfile and item.is_midi and not item.duration:
                item.duration = "----"

        if isfile and item.marked: tag1 = app.settings["marked_char"]
        if isfile and item is app.file_object_playing:
            tag2 = app.settings["playing_char"]
        elif app.is_streaming and app.mode == "playlist" and i == app.index_playing:
            tag2 = app.settings["playing_char"]
        if isfile and app.list_view == "paths":
            try:
                filepath = Path(item.fullpath)
                name = str('~' / filepath.relative_to(Path.home()))
            except ValueError:
                name = str(item.fullpath)

        elif isfile and app.list_view == "file_info":
            spacing = max(24, max_width - 38)
            name = item.name[:spacing].ljust(spacing)
            size = round(item.size/(1024*1024),2)
            if size >= 1:
                size = f"{item.size/(1024*1024):.2f} MB"
            else:
                size = f"{item.size/(1024):.2f} kb"

            mod_date = str(datetime.datetime.fromtimestamp(item.date)).split('.')[0]

            name = f"{name}   {size.rjust(10)}   {mod_date}"

        #elif isfile and app.list_view in ("metadata", "custom1", "custom2"):
        elif isfile and (app.list_view == "metadata" or str(app.list_view).startswith("custom")):
            show_meta = True

        elif isfile and item.is_midi and item.midi_config:
            config = str(item.midi_config)
            if '/' in config:
                config = config.split('/')[-1]
            name = item.name[:max_width-18].ljust(max_width-18)
            name = f"{name}{config.rjust(15)} "

        elif isdir and app.settings["show_dir_size"]: ##WIP
            size = str(item.size)+' '
            name = name[:max_width-8].ljust(max_width-8)
            name = f"{name}{size.rjust(6)}"

        else:
            name = name[0:max_width-2]
        name = f"{name}".ljust(max_width)
        cprint(f"{tag1}{tag2}", style = app.theme.style_icons, end = None)
        ypos, _ = screen.getyx()

        if i == index and not app.screensaver_running:
            cs = app.theme.style_selected
        elif isfile and item.name in (player.filename, app.midi_filename) and i == app.index_playing:
            cs = app.theme.style_playing
        elif app.is_streaming and app.mode == "playlist" and i == app.index_playing:
            cs = app.theme.style_playing
        else:
            cs = app.theme.style_main
        if show_meta:
            draw_metadata(i, index, item, max_width, isfile, support_screensaver = True)
        else:
            cprint(name, style = cs, support_screensaver = True)
        if tag2:
            cprint(f"{tag1}{tag2}", x = 0, y = ypos, style = app.theme.style_icons)
        total += 1
    y, x = screen.getyx()
    #There was an attempt... to fix a bug
    #Stop Japanse text from wrapping/polluting the last line in the list
    cprint("  ", x=0, y=y, style=app.theme.style_icons)
    cprint(" ", x=2, y=y, fill=True, style=app.theme.style_main)

    return index

class NestedDict(defaultdict):
    def __init__(self, *args, **kwargs):
        super(NestedDict, self).__init__(NestedDict, *args, **kwargs)
    def __repr__(self):
        return repr(dict(self))

def probe_metadata():
    while app.running:
        try:
            #crash() ##--for debug purposes
            array = []
            index = 0
            is_visible = False
            if app.visible_files_to_probe:
                array = app.visible_files_to_probe
                index = -1
                is_visible = True
            elif app.playlist_to_probe and (app.mode == "playlist" or not app.filelist_to_probe):
                array = app.playlist_to_probe
            else:
                array = app.filelist_to_probe
            try:
                obj = array.pop(index)
            except IndexError:
                if is_visible:
                    time.sleep(.1)
                else:
                    time.sleep(.5)
                continue
            if app.master and is_visible and not array:
                save_sync_data()
            if obj.probed or obj.is_midi or obj.is_stream or obj.ext == "m3u":
                obj.probed = True
                continue
            if obj.duration and not obj.duration == "----" and obj.artist and not obj.artist == "????":
                obj.probed = True
                continue
            app.is_probing = True
            cmd = "ffprobe"
            args = ["-show_format", "-print_format", "json", f"{obj.fullpath}"]
            with threading.Lock(): #stop multiple threads from accessing the same file at once
                try:
                    s = subprocess.run([cmd, *args], text=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
                    data = s.stdout
                except (subprocess.CalledProcessError, UnicodeDecodeError, FileNotFoundError):
                    data = ''
            try:
                file_info = NestedDict(json.loads(data)['format'])
            except (KeyError, json.decoder.JSONDecodeError):
                file_info = {}
            try:
                tags = file_info['tags']
            except KeyError:
                tags = {}
            title = tags.get("title", '').title()
            artist = tags.get("artist", '')
            duration = file_info.get("duration", '')
            length = file_info.get("duration", 0)
            rate = file_info.get("bit_rate", 'n/a')
            year = tags.get("year", None)
            date = tags.get("date", '')
            genre = tags.get("genre", '')
            album = tags.get("album", '')
            track = tags.get("track", '1')
            comment = tags.get("comment", '')
            if obj.is_mod:
                if title and title.strip():
                    obj.title = title.strip()
                    if obj.title and not obj.title[0].isalnum():
                        obj.title = obj.title[1:]
                else:
                    title = obj.name.replace("_", " ").title() #new bit to fix bug
                obj.genre = "Mod/Tracker"
                if not year and comment:
                    year = [item for item in app.years if f"{item}" in comment or f"{item}" in date or f"{item}" in obj.name]
                    if year:
                        obj.year = year[0]
                    else:
                        year = [item for item in app.short_years if f"{item}" in comment]
                        if year: obj.year = f"19{year[0]}"
                if not artist and comment:
                    if "\n" not in comment:
                        lines = [comment]
                    else:
                        lines = comment.lower().split('\n')
                    match1 = [line.strip() for line in lines if "@" in line]
                    match2 = [line.strip() for line in lines if "(c)" in line]
                    if match1:
                        match1 = match1[0].split("@")[0]
                        match1 = "".join([letter for letter in\
                        match1 if letter.replace('.', 'a').replace(' ','a').replace('_','a').isalpha()])
                        if " " not in match1.strip():
                            obj.artist = match1.strip()
                        else:
                            obj.artist = match1.split()[-1]
                    elif match2:
                        part1, part2 = match2[0].split("(c)", 1)
                        part1, part2 = part1.strip(), part2.strip()
                        if part2 and not part2[0].isdigit():
                            obj.artist = part2
                        else:
                            obj.artist = part1
                    obj.artist = obj.artist.replace("\\", "").replace("email", "")

            else:
                match = ((artist and obj.artist == "????"), (duration and obj.duration == "----"), (artist and not obj.artist))
                if any(match): ##m4a and others aren't being read properly by music-tag
                    if title.strip() and len(title) > 2: obj.title = title.strip()
                    if artist.strip(): obj.artist = artist.strip()
                    if album.strip(): obj.album = album.strip()
                    obj.genre = genre
                    if year:
                        obj.year = year
                    elif date:
                        obj.year = date[:4]
                    try:
                        if rate: obj.rate = f"{int(int(rate)/1000)} kbs"
                    except ValueError:
                        obj.rate = rate
                    obj.track = track

            try:
                duration = float(duration)
                obj.duration_raw = duration
                obj.duration = format_time(duration, long = False)
            except ValueError:
                obj.duration = '----'
                obj.duration_raw = 0
            obj.length = length
            obj.comment = comment
            obj.probed = True

        except Exception as e:
            app.visible_files_to_probe, app.playlist_to_probe, app.filelist_to_probe = [], [], []
            app.thread_error = f"Exception in probe_metadata(), thread pool failed.\n{e}"
    app.quit_counter -= 1

def get_metadata(item, default_album = ''):
    try:
        if item.is_midi or item.is_mod:
            raise TypeError
        tag = app.music_tag.load_file(item.fullpath)
        title = tag["title"].value
        album = tag["album"].value
        artist = tag["artist"].value
        year = tag["year"].value
        genre = tag["genre"].value
        comment = tag["comment"].value
        lyrics = tag["lyrics"].value
        length = duration = tag["#length"].value
        track = tag["tracknumber"].value
        totaltracks = tag["totaltracks"].value
        rate = tag["#bitrate"].value

    except Exception:
        title, album, artist, year, genre, duration, length = '', '', '', '', '', 0, 0
        track = '1'; rate = "n/a"; comment = ''; lyrics = ''; totaltracks = 0
        duration_raw = 0

    else:
        try:
            duration_raw = float(duration)
        except ValueError:
            duration_raw = 0
        duration = format_time(duration, long = False)

    if not title or (title and not title.strip()):
        title = Path(item.name).stem.title()
        if item.is_midi:
            title = f"{title}"
            genre = "MIDI"
    if not album:
        if default_album: album = default_album
        else: album = Path.cwd().name
    if not artist: artist = "????"
    if not year: year = "----"
    if not duration: duration = "----"
    item.title = title.strip(); item.album = album.strip()
    item.artist = artist.strip(); item.year = year
    item.duration = duration; item.genre = genre.strip()
    item.duration_raw = duration_raw
    item.length = length
    item.track = track or '1'
    item.totaltracks = totaltracks
    item.comment = comment
    if not comment:
        item.comment = lyrics
    try:
        if rate:
            item.rate = f"{int(int(rate)/1000)} kbs"
        else:
            rate = "n/a"
    except ValueError:
        item.rate = rate

def apply_tags(key):
    """Apply and save tags using 'music_tag'"""
    """NOTE: There is a bug in music_tag and/or mutagen where 'year' is not saved for MP3s"""
    if app.mode == "filelist":
        obj = app.all[app.index]
        array = app.all
    elif app.mode == "playlist" and app.playlist:
        obj = app.playlist[app.playlist_index]
        array = app.playlist
    else:
        return
    marked = [item for item in array if type(item) is not str and item.marked]
    if not marked:
        if type(obj) is str or obj.is_dir or obj.is_midi: return
        default = getattr(obj, key)
    else:
        default = getattr(marked[0], key)
        if key == "title":
            app.send_msg("Error: You can't apply TITLE to multiple items")
            return
    if default in ("????", "----"): default = ''
    tag = get_text(f"{key.upper()} tag: ", default_text = default, additional_chars = "()&[]!?,", allow_spaces = True)
    if not tag: return

    if not tag.strip() or (not marked and tag.strip() == default): return
    if not marked:
        write_metadata(obj, key, tag)
    elif confirmation(f"Apply tags to {len(marked)} items? (y/n)"):
        for item in marked:
            item.marked = False  #might not want to clear selection, when placing tags
            write_metadata(item, key, tag)
    else:
        return

def write_metadata(obj, key, tag):
    try:
        import music_tag
    except ModuleNotFoundError:
        app.send_msg("Error: music-tag required for writting tags")
        return
    try:
        m = music_tag.load_file(obj.fullpath)
        m[key] = tag
        m.save()
    except Exception:
        app.send_msg("Error, can't apply tags to this format")
    else:
        get_metadata(obj)
        app.updated = True

def draw_metadata(i, index, item, max_width, isfile, support_screensaver = False):
    draw_list_view(app.list_view.current.name, i, index, item, max_width, isfile, support_screensaver)

def draw_list_view(name, i, index, file, max_width, isfile, ss = False):
    try:
        view = ListView.hash[name]
    except KeyError:
        app.send_msg(f"Error, view '{name}' does not exist")
        return
    y, _ = screen.getyx()
    if i == index:
        cs = app.theme.style_selected
    elif isfile and file.name in (player.filename, app.midi_filename) and i == app.index_playing:
        cs = app.theme.style_playing
    else:
        cs = app.theme.style_main
    view.draw(file, y, style = cs)

@trap
def draw_progress_bar(pos, x = 0, y =-2, max_width = None, color = 0):
    try:
        c = app.theme.color_bars
    except AttributeError:
        c = extract_color(color)
    if c and  app.theme_index in (6, 7):
        color = c + curses.A_REVERSE
    if max_width is None:
        max_height, max_width = screen.getmaxyx()
    try:
        size = int(max_width * pos/100)
        cprint("=" * size, x=x, y=y, color = color + curses.A_BOLD, end ='')
        sep = '=' if app.theme_index in (6,7) else '|'
        cprint(sep, color = color)
    except TypeError:
        pass

def is_av(filename, check_mime = False):
    if check_mime:
        try:
            mtype = magic.from_file(filename, mime=True)
        except (IsADirectoryError, PermissionError): ##new bit to fix bug with python3-magic
            return False
        if "audio" in mtype or "video" in mtype:
            return True
        if  Path(filename).suffix.lower() == ".m3u":
            return True
    else:
        try:
            filename = filename.name
        except AttributeError:
            pass
        ext = Path(filename).suffix.lower()
        if ext and ext[1:] in app.extensions:
            return True
    return False

def show_playlists():
    if str(app.cwd) == "~/.config/mplay/playlists" and app.return_dir:
        path = app.return_dir
        app.return_dir = ''
        if app.mode == "playlist": toggle_playlist()
    elif app.mode == "filelist":
        path = Path("~/.config/mplay/playlists").expanduser()
        app.return_dir = app.cwd.expanduser()
        dirname = path.parent
        dirname.mkdir(parents = True, exist_ok = True)
    else:
        return
    update_directory(path)

def update_directory(name):
    if name == "../": app.return_dir = ''
    app.filter = ''
    path = Path(name).expanduser()
    if not path.is_dir():
        app.send_msg("Error: Directory doesn't exist")
        return
    if not app.mode == "filelist":
        return #to stop dir changes in other modes
    try:
        app.prev = Path.cwd().name
    except FileNotFoundError:
        app.prev = None
    try:
        if name != "../" and app.all[app.index].is_dir: #keep
            app.prev = app.all[app.index].name ##was prev_dir, but looked ike a mistake
    except (AttributeError, IndexError):
        pass
    if not app.msg:
        cprint("   Processing...", x=-16,y=0,style = app.theme.style_header)
        screen.refresh()
    app.index = 0
    app.files = []
    app.directories = []
    if path:
        try:
            os.chdir(path)
        except PermissionError:
            app.send_msg("Error: Permission denied")
            return
        try:
            app.cwd = Path.cwd()
        except FileNotFoundError:
            app.cwd = None
        if "home" in str(app.cwd):
            path = "~/" + "/".join(str(app.cwd).split('/')[3:]) + '/'
            app.cwd = Path(path)
    scanned = list(os.scandir())
    size = len(scanned)
    FileObj.data = []
    app.filelist_to_probe = []
    [processed_dir(i, item, size) for i, item in enumerate(scanned)]
    update_filelist()
    if name == "../" and app.prev:
        try:
            app.index = [item.name for item in app.all if type(item) != str].index(app.prev) + 1
        except ValueError:
            app.index = 0

def processed_dir(i, item, size):
    show_load_progress(i, size)
    f = None
    if item.is_dir() and not item.name.startswith('.'):
        f = FileObj(item)
        calc_dir_size(f)
    elif is_av(item.path, check_mime = app.check_mime):
        f = FileObj(item)
        get_metadata(f)
        if app.settings["get_meta_with_ffprobe"]:
            if not f.is_midi and not f.is_stream and not f.ext == "m3u" and (not f.duration or f.duration in ("----", "00:00")):
                app.filelist_to_probe.append(f)
            app.is_probing = True

        f.path = Path(f"{app.cwd}/{f.name}")
        f.fullpath = f.path.expanduser()
    return f

def stop_loading():
    key.detect()
    if key('c','q',"UP"):
        app.send_msg("LOAD CANCELLED!!!")
        return True
    return False

def update_filelist():
    if not app.filter:
        app.all = ["../"]
    else:
        app.all = []
    dirs = [item for item in FileObj.data if item.is_dir]
    files = [item for item in FileObj.data if not item.is_dir]
    sorted_dirs = sorted(dirs, key=operator.attrgetter(app.sort), reverse = app.reverse)
    app.files = sorted_files = sorted(files, key=operator.attrgetter(app.sort), reverse = app.reverse)
    app.all.extend(sorted_dirs)
    app.all.extend(sorted_files)
    app.files_loaded = app.files
    app.all_loaded = app.all
    if app.filter:
        filter_filelist()

def calc_dir_size(dir):
        path = dir.fullpath
        try:
            dir.size = sum(1 for item in os.scandir(path) if item.is_dir() or is_av(item))
        except PermissionError:
            dir.size = -1
        app.updated = True

def get_playlist_size():
    if not app.playlist_size:
        size = sum([item.size for item in app.playlist])
        if size/(1024*1024) >= 1000:
            app.playlist_size = f"{size/(1024*1024*1024):.2f} GB"
        elif size >= 1:
            app.playlist_size = f"{size/(1024*1024):.2f} MB"
        else:
            app.playlist_size = f"{size/(1024):.2f} kb"
    return app.playlist_size

def get_playlist_duration():
    if app.playlist_to_probe:
        length = len(app.playlist_to_probe)
        if length % 50 or length == 1:
            app.playlist_duration = 0
    if not app.playlist_duration:
        app.playlist_duration = format_time(sum([item.duration_raw for item in app.playlist]))
    return app.playlist_duration

def format_time(secs, long = True):
    if secs is None: secs = 0
    if long:
        if secs >= 86400:
            ftime = time.strftime("%dd %Hh %Mm", time.gmtime(secs))
        else:
            ftime = time.strftime("%Hh %Mm %Ss", time.gmtime(secs))
    else:
        if secs >= 3600:
            ftime = time.strftime("%H:%Mm", time.gmtime(secs))
        else:
            ftime = time.strftime("%M:%S", time.gmtime(secs))
    return ftime

def clear_line(x = None, y = None, win = None):
    win, x, y, _, _, _, _ = init_window(x = x, y = y, win = win)
    move(x, y)
    win.clrtoeol()

@trap
def move(x, y, win = None):
    # May need to trap OverflowError before final release
    # But I'd rather figure out why they are happening
    if win is None: win = screen
    win.move(y, x)

def load_config(file, settings):
    #custom_view = False
    #elements2 = []
    custom_views = {}
    info = []

    try:
        with open(file, 'r') as f:
            data = {}
            lines = f.readlines()    
    except FileNotFoundError:
        return settings
    for line in lines:
        if line.startswith("#") or not '=' in line: continue
        key, _, value = [item.strip() for item in line.partition('=')]
        if value.isdecimal(): value = int(value)
        elif '.' in value and value.replace('.', '', 1).isdecimal():
            value = float(value)
        elif value.lower() in ("true", "yes", "on"): value = True
        elif value.lower() in ("false", "no", "off"): value = False
        elif value.lower() == "none": value = None
        if key == "custom_view": key = 'custom_view1'

        if key.startswith("custom_view"):
            if "_element" in key:
                key = key.split("_element")[0]
            try:
                if value.count(',') == 2:
                    attr, align, offset = value.split(',')
                else:
                    attr, align = value.split(',')
                    offset = 0
                offset = int(offset)
                element = ViewElement(attr,align,offset)
                name = key.replace('_view', '')
                if name not in custom_views:
                    custom_views[name] = []
                custom_views[name].append(element)
                info.append({name:(attr, align, offset)})

            except (TypeError, ValueError) as e:
                #crash()

                app.send_msg("Error: Custom View not valid")
        else:
            data[key] = value
    #END for loop

    for key in settings:
        if key in data:
            settings[key] = data[key]

    if custom_views:
        for key, value in custom_views.items():
            app.custom_views[key] = ListView(value, name = key)
        #raise Exception(info)

    return settings

def save_config(file, settings):
    Path(file).parents[0].mkdir(parents=True, exist_ok=True) ##create missing dirs
    data = []
    for key, value in settings.items():
        data.append(f"{key} = {value}")
    with open(file, 'w') as f:
        f.write('\n'.join(data))

def save_sync_data(sync_data = None, erase = False):
    if not sync_data and not is_file(app.file) and not erase: return
    path = Path("~/.config/mplay/sync").expanduser()
    path.mkdir(parents=True, exist_ok=True) ##create missing dirs
    file_path = path/"data"
    if erase:
        file_path.unlink(missing_ok=True)
        return
    if not sync_data:
        color_data = 'None' if erase else str(app.settings["color_override"])
        quit_status = not app.running
        sync_data = SyncData(app.file, color_data, quit = quit_status)
    with open(file_path, "wb") as f:
        pickle.dump(sync_data, f)

def load_sync_data():
    path = Path("~/.config/mplay/sync").expanduser()
    data_path = path/"data"
    sync_data = None
    try:
        with open(data_path, 'rb') as f:
            data = pickle.load(f)
        color_data = data.color
        if color_data == "None":
            color_data = None
        play_data = data.path
        if play_data == "None":
            play_data = None
            raise FileNotFoundError
    except FileNotFoundError:
        app.send_msg("Error: No sync data, is master running?", .3)
        play_data, color_data = None, None
        data = None
    except EOFError:
        return ##might need to do something else here

    if data and data.quit:
        app.running = False
    if play_data:
        if app.file:
            prev_title = app.file.title
            prev_duration = app.file.duration
        else:
            prev_title = None
            prev_duration = None
        if not prev_title == data.file.title or not prev_duration == data.file.duration\
        or not play_data == app.file.fullpath:
            app.file = data.file
            app.playlist_main = app.playlist = [app.file]
            player.pause = True
            if app.screensaver_running:
                if screensaver.random:
                    randomize_screensaver()
                elif screensaver.engine in (1,2):
                    screensaver.data = None
                elif screensaver.engine == 3:
                    matrix_transition()
                elif screensaver.engine == 4:
                    khaos_transition()
                elif screensaver.engine == 5:
                    plankton_transition()
                elif screensaver.engine == 6:
                    tetragon_transition()
    if color_data != app.settings["color_override"]:
            app.settings["color_override"] = color_data
            reset = False if color_data else True
            make_themes(reset)
            change_theme(app.theme_index, msg = False)
            if khaos_playing():
                screensaver.theme_colors = get_theme_colors(singles_only = True)
                override = get_alt_or_main_color()
                screensaver.theme_colors.append(override)
                screensaver.color = override #change screensaver color
            elif plankton_playing() or tetragon_playing():
                screensaver.reset = True

def get_alt_or_main_color():
    try:
        alt = COLOR.map[app.settings["color_override"]]
        return alt
    except KeyError:
        return app.theme.color_main

def sync_file(play_data):
    if play_data and not play_data == "None":
        try:
            file = FileObj(play_data)
        except FileNotFoundError:
            app.send_msg("An error ocurred. Is master running?")
            return
        if app.settings["get_meta_with_musictag"] or app.settings["get_meta_with_ffprobe"]:
            get_metadata(file, default_album = file.path.parent.name)
        if app.settings["get_meta_with_ffprobe"]:
            app.playlist_to_probe.append(file)
        if not app.file or (app.file and app.file.path != file.path):
            app.file = file
            app.playlist_main = app.playlist = [app.file]
            if not app.file.is_midi:
                play(0, isPlaylist = True)
                Tried_to_play_file()

            player.pause = True
            if app.screensaver_running:
                if screensaver.engine in (1,2):
                    screensaver.data = None
                elif screensaver.engine == 3:
                    matrix_transition()
                elif screensaver.engine == 4:
                    khaos_transition()
                elif screensaver.engine == 5:
                    plankton_transition()
                elif screensaver.engine == 6:
                    tetragon.transition()

    else:
        stop()
        app.send_msg("No play data, is master running?")

def is_file(obj, ext = None):
    try:
        if obj.is_dir:
            return False
        if ext and not obj.name.lower().endswith(ext):
            return False
    except AttributeError:
        return False
    return True

@trap
def strip_style(style):
    """Usage: if COLOR.WHITE in strip_style(style): doSomething()"""
    stripped = []
    styles = (0, curses.A_DIM, curses.A_BOLD, curses.A_UNDERLINE, curses.A_REVERSE,\
    curses.A_STANDOUT, curses.A_BLINK, curses.A_ITALIC, curses.A_LOW)
    for s1 in styles:
        for s2 in styles:
            for s3 in styles:
                stripped.append(style - (s1 + s2 + s3))
    return set(stripped)

@trap
def extract_color(style):
    result = strip_style(style)
    for color in COLOR.map.values():
        if color in result: return color
    return 0

##Class definitions
class Color:
    def __init__(self, use_color = True):
        self.map = {}
        self.set(use_color)
    def set(self, use_color):
        color_supported = curses.has_colors()
        if color_supported and use_color:
            curses.start_color()
        curses.use_default_colors()

        colors = "WHITE CYAN MAGENTA BLUE YELLOW GREEN RED BLACK".split()
        id = 1
        for fg in colors:
            cursed_fg = getattr(curses,f"COLOR_{fg}")
            curses.init_pair(id, cursed_fg, -1)
            key = fg.lower()
            if not use_color:
                setattr(self, fg, 0)
                self.map[key] = 0
            else:
                setattr(self, fg, curses.color_pair(id))
                self.map[key] = curses.color_pair(id)
            id += 1
            for bg in colors:
                cursed_bg = getattr(curses, f"COLOR_{bg}")
                if app.reverse_colors:
                    curses.init_pair(id, cursed_bg, cursed_fg)
                else:
                    curses.init_pair(id, cursed_fg, cursed_bg)

                key = f"{fg}-on-{bg}".lower()
                if not all((use_color, color_supported)):
                    setattr(self, f"{fg}_ON_{bg}", 0)
                    if not fg == bg:
                        self.map[key] = 0
                else:
                    #if app.reverse_colors: fg, bg = bg, fg
                    setattr(self, f"{fg}_ON_{bg}", curses.color_pair(id))
                    if not fg == bg:
                        self.map[key] = curses.color_pair(id)
                id += 1

    def get(self, color_string):
        return getattr(self, color_string)

class Key:
    """Example:
    nc.detect_keys()
    if nc.key('RIGHT'): cprint('RIGHT arrow pressed')
    if nc.key('Q', 'q'): quitProgram()"""
    def __init__(self):
        self.pressed = None
        self.raw = None
        self.last_pressed = None
        self.time_of_last_press = 0
        self.repeat_time = .1
        self.repeating = False
        self.special = {259: "UP", 258: "DOWN", 261: "RIGHT",
        260: "LEFT", 10: "ENTER", 13: "ENTER", 32: "SPACE",
        330: "DELETE", 263: "BACKSPACE", 27: "ESC", 9: "TAB",
        262: "HOME", 360: "END", 339: "PG_UP", 338: "PG_DOWN",
        353: "BACK_TAB", 331: "INSERT", 409: "MOUSE"}

    def __call__(self,*args):
        if not self.pressed: return False
        if self.raw in args: #process raw keycodes
            return True
        #process special keys
        if self.raw in self.special.keys():
            if self.special[self.raw] in args \
            or "KEY_" + self.special[self.raw] in args:
                return True
        try:
            #process other keys, numbers must be passed as strings
            if self.pressed in args: return True
        except Exception:
            return False
        return False
    def reset(self):
        self.pressed = None
        self.raw = None
    def detect(self, win = None, update_screen = False):
        if not win: win = screen
        if update_screen:
            win.refresh()
        k = win.getch()
        if k == -1: k = None
        self.raw = k

        if k is not None and self.raw:
            if k in self.special.keys():
                self.pressed = self.special[self.raw]
            else:
                self.pressed = chr(k)
            if self.last_pressed == self.pressed:
                self.repeating = True
            else:
                self.repeating = False
            self.time_of_last_press = time.time()
            self.last_pressed = self.pressed
        else:
            if time.time() > self.time_of_last_press + self.repeat_time:
                self.repeating = False
                self.last_pressed = ''
            self.pressed = ""
        if update_screen:
            win.erase()

class Request(dict):
    """Handler for command line arguments
    Usage:
        request = Request()
        if request.was('h', 'help'):
            show_help()
        elif request.was('file'):
            path = request.file"""
    def __getattr__(self, key):
        try:
            return self.__getitem__(key)
        except KeyError:
            raise AttributeError(key)
    def __init__(self, args = sys.argv):
        self._name = args[0]
        self.made = False
        self.first = None
        args = self.__expand(args)
        for i, arg in enumerate(args):
            if i < 1: continue
            elif i == 1 and not arg.startswith('-'):
                self.first = arg
                continue

            arg = arg.strip('-')
            try:
                value = args[i+1]
                if value.startswith('-'):
                    value = None
            except (AttributeError, TypeError, IndexError):
                value = None
            if not hasattr(self, arg):
                self.__setitem__(arg.replace('-','_'), value)
            self.made = True

    def __call__(self, *args):
        """Returns True if Request has attribute.
        Attributes are automatically added based on flags."""
        for attribute in args:
            try:
                if hasattr(self, attribute): return True
            except AttributeError:
                continue
        return False
    was = __call__

    def __expand(self, args):
        """Expands '-mco filename' into -m -c -o 'filename'
        and converts '--quiet=true' into '--quiet true'"""
        expanded = []
        for i, item in enumerate(args):
            if not item.startswith("--") and item.startswith('-'):
                for c in item.replace('-', '', 1):
                    expanded.append('-' + c)
            else:
                if '=' in item:
                    items = item.split('=', 1)
                    expanded.extend(items)
                else:
                    expanded.append(item)
        return expanded

class SimpleState:
    class State:
        def __init__(self, parent, name, index):
            self.parent = parent
            self.name = name
            self.index = index
        def __str__ (self):
            return self.name
        def __repr__(self):
            return self.name
        def __eq__(self, other):
            if isinstance(other, int):
                return self.index == other
            elif isinstance(other, str):
                return self.name == other
            elif isinstance(other, SimpleState.State):
                return self.name == other.name
            else:
                return False
        def __bool__(self):
            return self.index == self.parent.index
    def __init__(self, *args):
        self.states = []
        if len(args) == 1:
            if type(args) is str:
                args = list(args)
            else:
                args = args[0]
        for i, arg in enumerate(args):
            state = SimpleState.State(self, arg, i)
            arg = arg.replace('-', '_')
            if hasattr(self, arg):
                raise ValueError(f"States must be unique values {arg}")
            setattr(self, arg, state)
            self.states.append(state)
        self.__index = 0
        self.__current = self.states[0]
    def __str__(self):
        return str(self.current)
    def __repr__(self):
        return str(self.current)
    def __eq__(self, other):
        if isinstance(other, SimpleState):
            return self.__index == other.index
        elif isinstance(other, str):
            return self.__current == other
        else:
            return self.__index == other
    def __bool__(self):
        return self.__current.name == self.__name
    def next(self):
        self.index += 1
    def prev(self):
        self.index -= 1
    def set(self, name):
        self.index = self.states.index(name)
    def randomize(self):
        import random
        current_index = self.index
        n = 0
        while n < 20 and current_index == self.index:
            self.index = random.randrange(0, len(self.states))
            n += 1
    @property
    def index(self):
        return self.__index
    @index.setter
    def index(self, value):
        if value > len(self.states) - 1:
            value = 0
        elif value < 0:
            value = len(self.states) - 1
        self.__index = value
        self.__current = self.states[self.__index]
    @property
    def current(self):
        return self.__current
    value = current
    @property
    def count(self):
        return len(self.states)

class ViewElement:
    def __init__(self, attr, align = "left", offset = 0):
        self.attr = attr
        self.align = align
        self.justify = False
        self.offset = offset
    def get_field(self, file, attr):
        try:
            field = str(getattr(file, attr))
        except AttributeError:
            field = ''
        if not field.strip() or field in ("----", "????", "n/a"):
            field = ''
        return field
    def draw(self, file, y = None, style = 0):
        if y is None:
            y, _ = screen.getyx()
        height, width = screen.getmaxyx()
        center = int(width/2)
        quarter = int(width/4)
        third = int(width/3)
        twothirds = third*2
        right = width-1
        is_a_file = is_file(file)
        ignore_char = None
        sep = chr(9474) #(9615)
        block = chr(9617)
        vert = chr(9472) #chr(9480)

        if self.align == "left":
            x = 0 + self.offset
        elif self.align == "quarter":
            x = quarter + self.offset
        elif self.align == "third":
            x = third + self.offset
        elif self.align in ("center", "half", "middle"):
            x = center + self.offset
        elif self.align == "twothirds":
            x = twothirds + self.offset
        elif self.align.startswith("justify"):
            self.justify = True
            ignore_char = '^'
            x = 0
        else:
            x = right + self.offset
        attr = self.attr
        try:
            if is_a_file and file.is_stream:
                if attr == "title": attr = "name"
                elif attr == "artist": attr = "title"
                elif attr == "duration": attr = "rate"
                if file.title == file.name:
                    file.title = "----"
            elif is_a_file and file.is_midi:
                if attr == "artist":attr = "midi_config"
            elif attr == "name": attr = "sortname"
            attribute = getattr(file, attr)
            if attr == "midi_config" and attribute:
                attribute = f"({attribute.stem})"
            elif attr == "midi_config":
                attribute = ''
            if attr == "size":
                attr = "hr_size"
            if attr == "hr_size" and attribute:
                attribute = attribute.rjust(9)
            elif attr == "artist" and attribute == "????":
                attribute = ''
            if is_a_file and file.is_stream:
                if attribute == "n/a": attribute = ''
                if is_a_file and " - " in file.title:
                    artist, title = file.title.split(" - ", 1)
                    if attr == "title": attribute = title
                    if attr == "album": attribute = artist
        except (KeyError, AttributeError):
            attribute = None

        if attribute is None:
            if attr == "folder":
                attribute = f"{Path(file.path).parent.stem}{Path(file.path).parent.suffix}"
            elif "_and_" in attr:
                try:
                    attr1, attr2 = attr.rsplit("_and_", 1)
                    if file.is_stream and attr1 == "title":
                        attr1 = "name"
                    attr1 = str(getattr(file, attr1))[:int(width/3)]
                    if attr2 == "duration":
                        field = self.get_field(file, attr2)
                        if field: field = field[:6].ljust(6)
                    elif attr2 == "year":
                        field = self.get_field(file, attr2)
                        if field: field = str(field)[:4]
                    elif attr2 == "ext":
                        field = self.get_field(file, attr2)
                        field = field[:4].rjust(4)
                    elif attr2 == "size":
                        field = self.get_field(file, "hr_size")
                        if field: field = field[:9].rjust(9)
                    elif attr2 == "genre":
                        field = self.get_field(file, attr2)
                        if not field.strip() and self.align == "justify-right":
                            field = "----"
                        field = field[:11].center(11)
                    elif attr2 == "midi_config":
                        field = self.get_field(file, attr2)
                        field = Path(field).stem
                        field = field[:12].center(12)
                    elif attr2 == "track":
                        field = self.get_field(file, attr2)
                        if "/" in field:
                            field, _ = field.split("/", 1)
                        elif " of " in field:
                            field, _ = field.split(" of ", 1)
                        field = field[:3].rjust(3, '0')
                    elif attr2 == "playlist_pos":
                        field = self.get_field(file, attr2)
                        field = field[:5].rjust(5, '0')
                    elif attr2 == "rate":
                        field = self.get_field(file, attr2)
                        if not field.strip() and self.align == "justify-right":
                            field = "--------"
                        field = field[:8].rjust(8)
                    else:
                        attribute = ''
                        field = None
                    if self.align == "justify-right":
                        attribute = f"{attr1} {sep} {field}"
                    elif field.strip():
                        attribute = f"{attr1} ({field.strip()})"
                    else:
                        attribute = attr1

                except (AttributeError):
                    app.send_msg("Error displaying custom view")
                    attribute = ''

            elif attr == "sep":
                attribute = sep
            elif attr == "block":
                attribute = block
            elif attr == "vert":
                attribute = vert
            else:
                attribute = ''
        if attribute in (sep, block, vert):
            text = f"{attribute}"
        else:
            text = f"  {attribute} "
        if x <= 2:
            text = f"{attribute} "
            x = 2
        text = text.replace('^', '-')
        if self.justify:
            wide_count = get_wide_count(text)
            if self.align == "justify-right":
                text = f"  {text[:int(width/3)+20]}  ".rjust(width - wide_count, '^')
            elif self.align == "justify-center":
                text = f"  {text[:width-20]}  ".center(width - wide_count, '^')
            elif self.align == "justify-left":
                text = f"{text}  ".ljust(width, '^')
            else:
                app.sendmsg("Error, justify failed")
                self.justify = False
        cprint(text, x = x, y = y, style = style,\
        fill = True, ignore_char = ignore_char,\
        support_screensaver = True)

class ListView:
    hash = {}
    def __init__(self, elements, name):
        self.elements = elements
        self.name = name
        ListView.hash[name] = self
    def draw(self, file, y, style = 0):
        height, width = screen.getmaxyx()
        last = len(self.elements) - 1
        cprint(' ', x = 2, y = y, style = style, fill = True,\
            support_screensaver = True)
        for i, element in enumerate(self.elements):
            is_title = "title" in element.attr
            is_duration = "duration" == element.attr
            if all((width < 120, not i==last, not is_title, i == 3 and element.align == "right")):
                continue
            elif all((width < 100, not i==last, not is_title, i >= 3)):
                continue
            elif all((width < 80, not is_title, not is_duration, i >= 2)):
                continue
            elif all((width < 60, not is_title, i)):
                continue
            element.draw(file, y, style)

class App:
    def __init__(self):
        self.msg = None
        self.error = None
        self.thread_error = None
        self.time = None
        self.quit = False
        self.seconds = 3
        self.screensaver = 0
        self.last_screensaver = 0
        self.screensaver_running = False
        self.screensaver_time = 0
        self.saver_data = None
        self.last_touched = time.time() + self.screensaver_time
        self.fps = 60
        self.update_time = Alarm(1/self.fps)
        self.screensaver_update_time = Alarm(1/self.fps)

        self.last_key = ''
        self.last_key_time = 0
        self.key_available = Alarm(.001)
        self.files_loaded = []
        self.all_loaded = []
        self.files = []

        self.filelist_to_probe = []
        self.playlist_to_probe = []
        self.visible_files_to_probe = []
        self.pool = None

        self.looping = True
        self.search = ''
        self.playmode = SimpleState("play-all", "random", "one-shot")
        self.stat_time = Alarm(.01)
        self.top, self.topmem, self.cpu, self.ram = None, None, None, None
        self.show_system_stats = False

        self.time = 0
        self.quit_counter = 1
        self.all = []
        self.alarm = None
        self.timeout = None
        self.current_file = None
        self.file_object_playing = None
        self.extensions = "ogg|oga|flac|spx|mod|xm|fm|s3m|med|col|669|it|mtm|mt2|dbm|stm|aiff|aif|au|cdr|wav|wma|m4a|m4b|webm|mp3|mp4|mov|avi|mkv|snd|mid|m3u|mo3|okt|ptm|amf|wv|wvc".split('|')


        self.kanji = "⻡⻢⻣⻤⻥⻦⻧⻨⻩⻪⻫⻬⻭⻮⻯⻰⻱⻲⻳⼀⼁⼂⼃⼄⼅⼆⼇⼈⼉⼊⼋⼌⼍⼎⼏⼐⼑⼒⼓⼔⼕⼖⼗⼘⼙⼚⼛⼜⼝⼞⼟⼠⼡⼢⼣⼤⼥⼦⼧⼨⼩⼪⼫⼬⼭⼮⼯⼰⼱⼲⼳⼴⼵⼶⼷⼸⼹⼺⼻⼼⼽⼾⼿⽀⽁⽂⽃⽄⽅⽆⽇⽈⽉⽊⽋⽌⽍⽎⽏⽐⽑⽒⽓⽔⽕⽖⽗⽘⽙⽚⽛⽜⽝⽞⽟⽠⽡⽢⽣⽤⽥⽦⽧⽨⽩⽪⽫⽬⽭⽮⽯⽰⽱⽲⽳⽴⽵⽶⽷⽸⽹⽺⽻⽼⽽⽾⽿⾀⾁⾂⾃⾄⾅⾆⾇⾈⾉⾊⾋⾌⾍⾎⾏⾐⾑⾒⾓⾔⾕⾖⾗⾘⾙⾚⾛⾜⾝⾞⾟⾠⾡⾢⾣⾤⾥⾦⾧⾨⾩⾪⾫⾬⾭⾮⾯⾰⾱⾲⾳⾴⾵⾶⾷⾸⾹⾺⾻⾼⾽⾾⾿⿀⿁⿂⿃⿄⿅⿆⿇⿈⿉⿊⿋⿌⿍⿎⿏⿐⿑⿒⿓⿔⿕〷〸〹〺〻ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんゔゕゖゝゞゟ゠ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶヷヸヹヺ"
        self.years = set(range(1985,2077))
        self.short_years = set(range(99,84,-1)) #changed list to set
        self.file = None
        self.reverse = False
        self.rd = {True: "descending ↓", False: "ascending ↑"}
        self.sort = "sort_name"
        self.updated = True
        self.index = 0

        self.index_playing = 1
        self.show_remaining = True
        self.show_path = False
        self.list_view = None
        self.custom_views = {}
        self.midi_is_playing = False
        self.midi_pid = None
        self.midi_process = None
        self.midi_filename = ''
        self.midi_config = None
        self.record_pid = None
        self.record_process = None

        self.playlist = []
        self.playlist_main = []
        self.playlist_filtered = []
        self.playlist = self.playlist_main
        self.playlist_index = 0
        self.playlist_cont = None
        self.playing = False
        self.playlist_is_playing = False
        self.playlist_reversed = False
        self.playlist_shuffled = False
        self.playlist_name = ''
        self.playlist_filename = ''
        self.playlist_filter = ''
        self.playlist_duration = 0
        self.playlist_size = 0

        self.running = True
        self.mode = "filelist"
        self.show_page = False
        self.lastpage = 1
        self.last_mode = None
        self.filter = ''
        self.prev_dir = ''
        self.return_dir = ''
        self.cwd = ''
        self.is_probing = False
        self.master = False
        self.sync = False
        self.sync_time = Alarm(.01)
        self.show_sync_footer = True
        self.stream_file = None
        self.is_streaming = False
        self.stream_counter = 0
        self.killall = False

        self.theme = Theme()
        self.theme_index = 1
        self.custom_theme = None
        self.theme_overrides = {}
        self.color_override = None
        self.settings = {"start_directory":"~/Music", "music_directory":"~/Music",
        "use_color":True, "default_theme":1, "color_override":"None",
        "default_view":None,
        "show_dir_size":True, "get_meta_with_musictag":False, "get_meta_with_ffprobe":False,
        "add_support_for":"alac,opus",
        "app_delay":.01, "playing_char":"▶", "marked_char": "▣",
        "index_follow_playlist":True,
        "confirm_before_delete":True,
        "spacebar_play_or_pause":False, "screensaver":1,
        "screensaver_time":45, "fps":60, 
        "pageflip":True,
        "detect_capslock": False,
        "entry_standout":False,
        "dancing_errors":False,
        "streaming_log":False,
        "custom_view1_element1":"duration,justify-left",
        "custom_view1_element2":"sep,left,9",
        "custom_view1_element3":"title_and_year,left,10",
        "custom_view1_element4":"artist_and_ext,justify-right",

        "custom_theme_style_main":None,
        "custom_theme_style_header":None, "custom_theme_style_bars":None,
        "custom_theme_style_selected":None, "custom_theme_style_playing":None,
        "custom_theme_style_icons":None}

        ##▣ ◈ ◉ ☑  ✔  ✱

        self.help_text = ("", "MPLAY -music player insprired by cplay. MIT License.", "",
        "mplay [directory] [options]", "",
        "  -m, --mono                monochrome mode",
        "  --theme=n                 start with theme (0-8)",
        "  --color=color             override main color",
        "  --color=?                 display valid colors",
        "  -b, --bold                show bold text when possible",
        "  -r, --reverse             reverse colors when possible",
        "  -s, --show-metadata       shows file metadata (slower)",
        "  -f, --fast                turns off metadata and screensaver",
        "  --screensaver=n           1-8 enables screensaver, 0 to disable",
        "  --screensaver_time=n      set screensaver activation time",
        "  --fps=n                   set screensaver fps",
        "  --scroll                  mplay scrolls instead of page flipping",
        "  --playlists               opens playlist directory",
        "  --radio                   opens 'net_radio.m3u' if available",
        "  --master                  set master conotroller",
        "  --sync                    set sync targets (controlled by master)",
        "  --kill                    kill any zombie processes after a crash",
        "  --check-mime              Slow, don't use unless your audio",
        "                            files have no extensions")
        self.color_map = {}
        self.gui_colors = []
        self.color_index = 0
        self.reverse_colors = False
        self.check_mime = False
        self.volume = 100
        self.music_tag = None
        self.show_tags = False
        self.debug = False
        self.debug_output = None
        self.kiosk_mode = False
        self.command_history = ['']
        self.stream_pos = 0

        self.custom_view1 = None
        self.custom_view2 = None
        self.show_static = False
        self.current_page = 1
        self.chooser_range = None
        self.moving_down = False

    def send_msg(self, msg, secs = None):
        self.msg = msg
        if secs is None: secs = self.seconds
        self.alarm = Alarm(secs)

    def has(self, attr):
        try:
            if hasattr(self, attr): return True
        except AttributeError:
            return False

class Theme:
    def __init__(self, style_main = 0, style_header = None, style_bars = None,\
    style_selected = None, style_playing = None, style_icons = None):
        self.style_main = style_main
        self.style_header = style_header or style_main
        self.style_bars = style_bars or style_main
        self.style_selected = style_selected or style_main + curses.A_REVERSE
        self.style_playing = style_playing or style_main
        self.style_icons = style_icons or style_main

    def extract_colors(self):
        self.color_main = extract_color(self.style_main)
        self.color_header = extract_color(self.style_header)
        self.color_bars = extract_color(self.style_bars)
        self.color_selected = extract_color(self.style_selected)
        self.color_playing = extract_color(self.style_playing)
        self.color_icons = extract_color(self.style_icons)
        self.color_screensaver = self.get_color_screensaver()

    def get_color_screensaver(self):
        if self.color_main in (COLOR.WHITE, COLOR.BLACK, COLOR.WHITE_ON_BLACK,\
        COLOR.BLACK_ON_WHITE):
            target = self.color_bars
        else:
            target = self.color_main
        if target not in app.single_colors:
            foreground, background = split_colors(target)
            if foreground not in (COLOR.WHITE, COLOR.BLACK):
                return foreground
            else:
                return background
        else:
            if target not in (COLOR.WHITE, COLOR.BLACK):
                return target
        return COLOR.GREEN

class FileObj:
    data = []
    def __init__(self, obj, hidden = False):
        self.path = p = Path(obj)
        try:
            self.fullpath = p.expanduser()
        except RuntimeError:
            self.fullpath = os.path.expanduser(obj)
        self.parent = p.parent
        self.name = p.stem + p.suffix
        self.sort_name = self.name.lower()

        self.ext = p.suffix[1:].lower()
        self.is_dir = p.is_dir()
        self.is_file = p.is_file()
        if str(self.path).startswith("http:") or str(self.path).startswith("https:"):
            self.is_stream = True
            self.url = self.fullpath = obj

        else:
            self.is_stream = False
            self.url = None
        self.website = ''
        self.station = ''
        self.is_midi = all((self.is_file, self.ext == "mid"))
        self.is_mod = self.ext in ("mod", "it", "xm", "s3m", "mo3", "med", "mtm", "669", "okt", "ptm", "amf", "mt2", "dbm")
        self.probed = False
        self.flagged = False #for use with dup searches

        try:
            s = p.stat()
            self.date = s.st_ctime #modification date
            self.size = s.st_size 
            size = round(self.size/(1024*1024),2)
            if size >= 1:
                self.hr_size = f"{self.size/(1024*1024):.2f} MB"
            else:
                self.hr_size = f"{self.size/(1024):.2f} kb"

        except FileNotFoundError:
            self.date = 0
            self.size = 0
        if self.is_dir: self.size = 0

        self.marked = False
        self.volume = None
        self.midi_config = None
        self.sort_title = self.name
        self.__title = self.name.title()
        self.__album = ''
        self.__artist = ''
        self.title_and_artist = self.name.title()
        self.artist_and_album = ''
        self.__year = ''
        self.duration = ''
        self.duration_raw = 0
        self.length = 0
        self.genre = ''

        self.__track = ''
        self.totaltracks = ''
        self.rate = ''
        self.comment = ''
        self.playlist_pos = 0
        if not hidden:
            FileObj.data.append(self)

    @property
    def track(self):
        return self.__track
    @track.setter
    def track(self, val):
        self.__track = str(val)
    @property
    def year(self):
        return self.__year
    @year.setter
    def year(self, val):
        self.__year = str(val)
    @property
    def title(self):
        return self.__title
    @title.setter
    def title(self, val):
        self.sort_title = val.lower()
        self.__title = val
        if self.is_stream:
            self.title_and_artist = self.name.title()
        else:
            self.title_and_artist = self.__title.title()

    @property
    def artist(self):
        return self.__artist
    @artist.setter
    def artist(self, val):
        self.__artist = val
        if val and not val == "????":
            if self.is_stream:
                self.title_and_artist = f"{self.__title[:30]} - {self.name[:30]}"
            else:
                self.title_and_artist = f"{self.__title} - {self.__artist.title()}"
                self.artist_and_album = f"{self.__artist} - {self.album}"

    @property
    def album(self):
        return self.__album
    @album.setter
    def album(self, val):
        self.__album = val
        if val:
            if self.is_stream:
                self.artist_and_album = self.title
            elif val and not val == "????":
                if not self.artist or self.artist == "????":
                    self.artist_and_album = val
                else:
                    self.artist_and_album = f"{self.artist} - {self.album}"
    def __str__(self):
        return self.name
    def __repr__(self):
        return self.name

class SyncData:
    def __init__(self, file = None, color = None, quit = False):
        self.file = file
        try:
            self.path = self.file.fullpath
            self.title = self.file.title
            self.name = self.file.name
        except AttributeError:
            self.path, self.title, self.name = '', '', ''
        self.color = color
        self.quit = quit

class Alarm:
    def __init__(self, secs):
        self.time = time.time() + secs
    def __call__(self):
        if self.time < time.time():
            return True
        return False

class Particle():
    data = []
    def __init__(self, char = '*', x = 0, y = 0, xdir = 0, ydir = 1, duration = 3, color=0, trail_color = None, trail = False, length = 3, trail_dir = "vertical", gravity = 0, no_draw = False):
        self.char = char
        self.x = x
        self.y = y
        self.xdir = xdir
        self.ydir = ydir
        self.trail = trail
        self.trail_dir = trail_dir
        self.gravity = gravity
        self.color = color
        self.trail_color = trail_color
        self.duration = duration
        self.length = length
        self.update_time = Alarm(1/app.fps)
        self.expired = Alarm(duration)
        self.no_draw = no_draw
        Particle.data.append(self)

    def delete(self):
        try:
            Particle.data.pop(Particle.data.index(self))
        except ValueError:
            pass
        del self

    def update(self):
        if self.update_time():
            self.x += self.xdir
            self.y += self.ydir
            if screensaver.bounce:
                height, width = screen.getmaxyx()
                if self.x > width:
                    self.x = width
                    self.xdir *= -1
                elif self.x < 0:
                    self.x = 0
                    self.xdir *= -1
                if self.y > height-1:
                    self.y = height-1
                    self.ydir *= -1
                elif self.y < 0:
                    self.y = 0
                    self.ydir *= -1
            if self.gravity:
                self.ydir = min(2, self.ydir + self.gravity)
            self.update_time = Alarm(1/app.fps)
        if self.expired():
            self.delete()
        else:
            self.draw()

    def draw(self):
        if self.no_draw: return
        x, y = int(self.x), int(self.y)
        height, width = screen.getmaxyx()
        if y > height - 2 or y in (-1, -2):
            if self.trail and y:
                self.draw_trail(x, y)
            return #trying to stop kanji from getting stuck on last line
        if x > 10000: x = 0 #added 4 lines to stop OverflowError
        if x < -10000: x = width
        if y > 10000: y = 0
        if y < -10000: y = height
        try:
            char = app.kanji[app.kanji.index(self.char)+y]
        except IndexError:
            try:
                char = chr(ord(self.char)+y)
            except ValueError:
                char = '.'
        except ValueError:
            char = self.char
        if screensaver.particle_override:
            if not screensaver.stars or not char == '.':
                char = screensaver.particle_override

        cprint(char, x, y, color = self.color)
        if self.trail and y:
            self.draw_trail(x, y)

    def draw_trail(self, x, y):
        height, width = screen.getmaxyx()
        if x > 10000: x = 0 #added 4 lines to stop OverflowError
        if x < -10000: x = width
        if y > 10000: y = 0
        if y < -10000: y = height
        if self.trail_color:
            color = self.trail_color
        elif screensaver.engine == 4: #khaos?
            color = self.color
        else:
            color = app.theme.color_screensaver
        n = 0
        size = max(1, int(self.length/7))
        rng = range(y - 1, y -self.length, -1)
        for i in rng:
            try:
                char = app.kanji[app.kanji.index(self.char)+(i+1)]
            except IndexError:
                try:
                    char = chr(ord(self.char)+(i+1))
                except ValueError:
                    char = '.'
            except ValueError:
                char = self.char
            if char in ('`', '.', "'"): char = random.choice(('.', '`', "'"))
            if screensaver.particle_override:
                char = screensaver.particle_override

            if i < 0: break
            if n < size: clr = color + curses.A_BOLD
            elif n < size*2: clr = color + curses.A_NORMAL
            elif n < size*3: clr = color + curses.A_DIM
            elif n < size*4: clr = COLOR.BLACK + curses.A_BOLD
            elif n < size*5: clr = COLOR.BLACK + curses.A_NORMAL
            else: clr = COLOR.BLACK + curses.A_DIM
            if random.randrange(10) == 1 and clr in (color + curses.A_NORMAL, color + curses.A_DIM):
                clr = COLOR.WHITE + curses.A_DIM
            elif random.randrange(20) == 1:
                char = ' '
            if self.trail_dir == "vertical":
                if i < height - 3 or x < width - 4:
                    cprint(char, x, i, color = clr)
            else:
                if n:
                    cprint(" ", x-n, y, color = COLOR.BLACK_ON_BLACK)
            n += 1

##RUN APP
request = Request() 
key = Key()
app = App()
curses.wrapper(main)
on_quit()

###---------------------------------------
### 2025 by unpythonic-coder | MIT License
###---------------------------------------

